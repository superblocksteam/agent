// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file plugins/common/v1/metadata.proto (package plugins.common.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * SQLMetadata represents metadata for any SQL based plugin.
 *
 * @generated from message plugins.common.v1.SQLMetadata
 */
export class SQLMetadata extends Message<SQLMetadata> {
  constructor(data?: PartialMessage<SQLMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.common.v1.SQLMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SQLMetadata {
    return new SQLMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SQLMetadata {
    return new SQLMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SQLMetadata {
    return new SQLMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: SQLMetadata | PlainMessage<SQLMetadata> | undefined, b: SQLMetadata | PlainMessage<SQLMetadata> | undefined): boolean {
    return proto3.util.equals(SQLMetadata, a, b);
  }
}

/**
 * This is nested so we can intuitively access it (i.e. plugins.common.v1.SQLMetadata.Minified).
 *
 * @generated from message plugins.common.v1.SQLMetadata.Minified
 */
export class SQLMetadata_Minified extends Message<SQLMetadata_Minified> {
  /**
   * If applicable, place the schema name here as well (i.e. my_schema.table_name).
   *
   * @generated from field: map<string, plugins.common.v1.SQLMetadata.Minified.Table> tables = 1;
   */
  tables: { [key: string]: SQLMetadata_Minified_Table } = {};

  constructor(data?: PartialMessage<SQLMetadata_Minified>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.common.v1.SQLMetadata.Minified";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tables", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SQLMetadata_Minified_Table} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SQLMetadata_Minified {
    return new SQLMetadata_Minified().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SQLMetadata_Minified {
    return new SQLMetadata_Minified().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SQLMetadata_Minified {
    return new SQLMetadata_Minified().fromJsonString(jsonString, options);
  }

  static equals(a: SQLMetadata_Minified | PlainMessage<SQLMetadata_Minified> | undefined, b: SQLMetadata_Minified | PlainMessage<SQLMetadata_Minified> | undefined): boolean {
    return proto3.util.equals(SQLMetadata_Minified, a, b);
  }
}

/**
 * @generated from message plugins.common.v1.SQLMetadata.Minified.Table
 */
export class SQLMetadata_Minified_Table extends Message<SQLMetadata_Minified_Table> {
  /**
   * <column_name>:<column_type>
   *
   * @generated from field: map<string, string> columns = 1;
   */
  columns: { [key: string]: string } = {};

  constructor(data?: PartialMessage<SQLMetadata_Minified_Table>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.common.v1.SQLMetadata.Minified.Table";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "columns", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SQLMetadata_Minified_Table {
    return new SQLMetadata_Minified_Table().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SQLMetadata_Minified_Table {
    return new SQLMetadata_Minified_Table().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SQLMetadata_Minified_Table {
    return new SQLMetadata_Minified_Table().fromJsonString(jsonString, options);
  }

  static equals(a: SQLMetadata_Minified_Table | PlainMessage<SQLMetadata_Minified_Table> | undefined, b: SQLMetadata_Minified_Table | PlainMessage<SQLMetadata_Minified_Table> | undefined): boolean {
    return proto3.util.equals(SQLMetadata_Minified_Table, a, b);
  }
}

/**
 * BucketsMetadata represents metadata for any Bucket based plugin.
 *
 * @generated from message plugins.common.v1.BucketsMetadata
 */
export class BucketsMetadata extends Message<BucketsMetadata> {
  constructor(data?: PartialMessage<BucketsMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.common.v1.BucketsMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BucketsMetadata {
    return new BucketsMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BucketsMetadata {
    return new BucketsMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BucketsMetadata {
    return new BucketsMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: BucketsMetadata | PlainMessage<BucketsMetadata> | undefined, b: BucketsMetadata | PlainMessage<BucketsMetadata> | undefined): boolean {
    return proto3.util.equals(BucketsMetadata, a, b);
  }
}

/**
 * This is nested so we can intuitively access it (i.e. plugins.common.v1.BucketsMetadata.Minified).
 *
 * @generated from message plugins.common.v1.BucketsMetadata.Minified
 */
export class BucketsMetadata_Minified extends Message<BucketsMetadata_Minified> {
  /**
   * @generated from field: repeated string names = 1;
   */
  names: string[] = [];

  constructor(data?: PartialMessage<BucketsMetadata_Minified>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.common.v1.BucketsMetadata.Minified";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BucketsMetadata_Minified {
    return new BucketsMetadata_Minified().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BucketsMetadata_Minified {
    return new BucketsMetadata_Minified().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BucketsMetadata_Minified {
    return new BucketsMetadata_Minified().fromJsonString(jsonString, options);
  }

  static equals(a: BucketsMetadata_Minified | PlainMessage<BucketsMetadata_Minified> | undefined, b: BucketsMetadata_Minified | PlainMessage<BucketsMetadata_Minified> | undefined): boolean {
    return proto3.util.equals(BucketsMetadata_Minified, a, b);
  }
}

