// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file plugins/kinesis/v1/plugin.proto (package plugins.kinesis.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { AWSConfig, DynamicWorkflowConfiguration } from "../../common/v1/plugin_pb.js";

/**
 * @generated from message plugins.kinesis.v1.Plugin
 */
export class Plugin extends Message<Plugin> {
  /**
   * @generated from field: optional string name = 1;
   */
  name?: string;

  /**
   * @generated from field: plugins.kinesis.v1.Plugin.KinesisConnection connection = 2;
   */
  connection?: Plugin_KinesisConnection;

  /**
   * @generated from field: plugins.kinesis.v1.Plugin.OperationType operation_type = 3;
   */
  operationType = Plugin_OperationType.UNSPECIFIED;

  /**
   * @generated from field: optional plugins.kinesis.v1.Plugin.KinesisPut put = 4;
   */
  put?: Plugin_KinesisPut;

  /**
   * @generated from field: optional plugins.kinesis.v1.Plugin.KinesisGet get = 5;
   */
  get?: Plugin_KinesisGet;

  /**
   * @generated from field: optional plugins.common.v1.DynamicWorkflowConfiguration dynamic_workflow_configuration = 6;
   */
  dynamicWorkflowConfiguration?: DynamicWorkflowConfiguration;

  constructor(data?: PartialMessage<Plugin>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.kinesis.v1.Plugin";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 2, name: "connection", kind: "message", T: Plugin_KinesisConnection },
    { no: 3, name: "operation_type", kind: "enum", T: proto3.getEnumType(Plugin_OperationType) },
    { no: 4, name: "put", kind: "message", T: Plugin_KinesisPut, opt: true },
    { no: 5, name: "get", kind: "message", T: Plugin_KinesisGet, opt: true },
    { no: 6, name: "dynamic_workflow_configuration", kind: "message", T: DynamicWorkflowConfiguration, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plugin {
    return new Plugin().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plugin {
    return new Plugin().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plugin {
    return new Plugin().fromJsonString(jsonString, options);
  }

  static equals(a: Plugin | PlainMessage<Plugin> | undefined, b: Plugin | PlainMessage<Plugin> | undefined): boolean {
    return proto3.util.equals(Plugin, a, b);
  }
}

/**
 * https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html#API_GetShardIterator_RequestSyntax
 *
 * @generated from enum plugins.kinesis.v1.Plugin.ShardIteratorType
 */
export enum Plugin_ShardIteratorType {
  /**
   * @generated from enum value: SHARD_ITERATOR_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: SHARD_ITERATOR_TYPE_AT_SEQUENCE_NUMBER = 1;
   */
  AT_SEQUENCE_NUMBER = 1,

  /**
   * @generated from enum value: SHARD_ITERATOR_TYPE_AFTER_SEQUENCE_NUMBER = 2;
   */
  AFTER_SEQUENCE_NUMBER = 2,

  /**
   * @generated from enum value: SHARD_ITERATOR_TYPE_AT_TIMESTAMP = 3;
   */
  AT_TIMESTAMP = 3,

  /**
   * @generated from enum value: SHARD_ITERATOR_TYPE_TRIM_HORIZON = 4;
   */
  TRIM_HORIZON = 4,

  /**
   * @generated from enum value: SHARD_ITERATOR_TYPE_LATEST = 5;
   */
  LATEST = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(Plugin_ShardIteratorType)
proto3.util.setEnumType(Plugin_ShardIteratorType, "plugins.kinesis.v1.Plugin.ShardIteratorType", [
  { no: 0, name: "SHARD_ITERATOR_TYPE_UNSPECIFIED" },
  { no: 1, name: "SHARD_ITERATOR_TYPE_AT_SEQUENCE_NUMBER" },
  { no: 2, name: "SHARD_ITERATOR_TYPE_AFTER_SEQUENCE_NUMBER" },
  { no: 3, name: "SHARD_ITERATOR_TYPE_AT_TIMESTAMP" },
  { no: 4, name: "SHARD_ITERATOR_TYPE_TRIM_HORIZON" },
  { no: 5, name: "SHARD_ITERATOR_TYPE_LATEST" },
]);

/**
 * @generated from enum plugins.kinesis.v1.Plugin.OperationType
 */
export enum Plugin_OperationType {
  /**
   * @generated from enum value: OPERATION_TYPE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: OPERATION_TYPE_GET = 1;
   */
  GET = 1,

  /**
   * @generated from enum value: OPERATION_TYPE_PUT = 2;
   */
  PUT = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Plugin_OperationType)
proto3.util.setEnumType(Plugin_OperationType, "plugins.kinesis.v1.Plugin.OperationType", [
  { no: 0, name: "OPERATION_TYPE_UNSPECIFIED" },
  { no: 1, name: "OPERATION_TYPE_GET" },
  { no: 2, name: "OPERATION_TYPE_PUT" },
]);

/**
 * @generated from enum plugins.kinesis.v1.Plugin.StreamIdentifier
 */
export enum Plugin_StreamIdentifier {
  /**
   * @generated from enum value: STREAM_IDENTIFIER_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STREAM_IDENTIFIER_STREAM_NAME = 1;
   */
  STREAM_NAME = 1,

  /**
   * @generated from enum value: STREAM_IDENTIFIER_STREAM_ARN = 2;
   */
  STREAM_ARN = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Plugin_StreamIdentifier)
proto3.util.setEnumType(Plugin_StreamIdentifier, "plugins.kinesis.v1.Plugin.StreamIdentifier", [
  { no: 0, name: "STREAM_IDENTIFIER_UNSPECIFIED" },
  { no: 1, name: "STREAM_IDENTIFIER_STREAM_NAME" },
  { no: 2, name: "STREAM_IDENTIFIER_STREAM_ARN" },
]);

/**
 * @generated from message plugins.kinesis.v1.Plugin.KinesisConnection
 */
export class Plugin_KinesisConnection extends Message<Plugin_KinesisConnection> {
  /**
   * @generated from field: plugins.common.v1.AWSConfig aws_config = 1;
   */
  awsConfig?: AWSConfig;

  constructor(data?: PartialMessage<Plugin_KinesisConnection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.kinesis.v1.Plugin.KinesisConnection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aws_config", kind: "message", T: AWSConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plugin_KinesisConnection {
    return new Plugin_KinesisConnection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plugin_KinesisConnection {
    return new Plugin_KinesisConnection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plugin_KinesisConnection {
    return new Plugin_KinesisConnection().fromJsonString(jsonString, options);
  }

  static equals(a: Plugin_KinesisConnection | PlainMessage<Plugin_KinesisConnection> | undefined, b: Plugin_KinesisConnection | PlainMessage<Plugin_KinesisConnection> | undefined): boolean {
    return proto3.util.equals(Plugin_KinesisConnection, a, b);
  }
}

/**
 * https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecord.html
 * https://docs.aws.amazon.com/kinesis/latest/APIReference/API_PutRecords.html
 *
 * @generated from message plugins.kinesis.v1.Plugin.KinesisPut
 */
export class Plugin_KinesisPut extends Message<Plugin_KinesisPut> {
  /**
   * @generated from field: string data = 1;
   */
  data = "";

  /**
   * @generated from field: string partition_key = 2;
   */
  partitionKey = "";

  /**
   * @generated from field: plugins.kinesis.v1.Plugin.StreamIdentifier stream_identifier_type = 3;
   */
  streamIdentifierType = Plugin_StreamIdentifier.UNSPECIFIED;

  /**
   * @generated from field: optional string stream_name = 4;
   */
  streamName?: string;

  /**
   * @generated from field: optional string stream_arn = 5;
   */
  streamArn?: string;

  constructor(data?: PartialMessage<Plugin_KinesisPut>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.kinesis.v1.Plugin.KinesisPut";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "partition_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "stream_identifier_type", kind: "enum", T: proto3.getEnumType(Plugin_StreamIdentifier) },
    { no: 4, name: "stream_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 5, name: "stream_arn", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plugin_KinesisPut {
    return new Plugin_KinesisPut().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plugin_KinesisPut {
    return new Plugin_KinesisPut().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plugin_KinesisPut {
    return new Plugin_KinesisPut().fromJsonString(jsonString, options);
  }

  static equals(a: Plugin_KinesisPut | PlainMessage<Plugin_KinesisPut> | undefined, b: Plugin_KinesisPut | PlainMessage<Plugin_KinesisPut> | undefined): boolean {
    return proto3.util.equals(Plugin_KinesisPut, a, b);
  }
}

/**
 * https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetRecords.html
 * we will need to get a shard iterator first
 * https://docs.aws.amazon.com/kinesis/latest/APIReference/API_GetShardIterator.html
 *
 * @generated from message plugins.kinesis.v1.Plugin.KinesisGet
 */
export class Plugin_KinesisGet extends Message<Plugin_KinesisGet> {
  /**
   * @generated from field: string shard_id = 2;
   */
  shardId = "";

  /**
   * @generated from field: plugins.kinesis.v1.Plugin.ShardIteratorType shard_iterator_type = 3;
   */
  shardIteratorType = Plugin_ShardIteratorType.UNSPECIFIED;

  /**
   * @generated from field: int32 limit = 4;
   */
  limit = 0;

  /**
   * not required by kinesis, but something we want to allow users to configure
   * this is the amount of time in milliseconds between asking kinesis to get records when polling in a loop
   *
   * @generated from field: int32 polling_cooldown_ms = 5;
   */
  pollingCooldownMs = 0;

  /**
   * these 2 are required depending on the shard iterator type selected
   *
   * @generated from field: optional string starting_sequence_number = 6;
   */
  startingSequenceNumber?: string;

  /**
   * @generated from field: optional string timestamp = 7;
   */
  timestamp?: string;

  /**
   * @generated from field: plugins.kinesis.v1.Plugin.StreamIdentifier stream_identifier_type = 8;
   */
  streamIdentifierType = Plugin_StreamIdentifier.UNSPECIFIED;

  /**
   * @generated from field: optional string stream_name = 9;
   */
  streamName?: string;

  /**
   * @generated from field: optional string stream_arn = 10;
   */
  streamArn?: string;

  constructor(data?: PartialMessage<Plugin_KinesisGet>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.kinesis.v1.Plugin.KinesisGet";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "shard_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "shard_iterator_type", kind: "enum", T: proto3.getEnumType(Plugin_ShardIteratorType) },
    { no: 4, name: "limit", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "polling_cooldown_ms", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "starting_sequence_number", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "timestamp", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 8, name: "stream_identifier_type", kind: "enum", T: proto3.getEnumType(Plugin_StreamIdentifier) },
    { no: 9, name: "stream_name", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 10, name: "stream_arn", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Plugin_KinesisGet {
    return new Plugin_KinesisGet().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Plugin_KinesisGet {
    return new Plugin_KinesisGet().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Plugin_KinesisGet {
    return new Plugin_KinesisGet().fromJsonString(jsonString, options);
  }

  static equals(a: Plugin_KinesisGet | PlainMessage<Plugin_KinesisGet> | undefined, b: Plugin_KinesisGet | PlainMessage<Plugin_KinesisGet> | undefined): boolean {
    return proto3.util.equals(Plugin_KinesisGet, a, b);
  }
}

/**
 * @generated from message plugins.kinesis.v1.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * @generated from field: repeated string streams = 1;
   */
  streams: string[] = [];

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "plugins.kinesis.v1.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "streams", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

