{
	"info": {
		"_postman_id": "network-isolation-tests",
		"name": "Ephemeral Worker Network Isolation Tests",
		"description": "Tests to verify network isolation for ephemeral workers with default-deny iptables.\n\nTest order is important - localhost tests run FIRST while fresh pods are available.\n\nThese tests verify that:\n- Sandbox CAN reach localhost (task-manager gRPC)\n- Sandbox cannot reach external HTTPS (blocked by iptables)\n- Sandbox cannot reach Redis (blocked by iptables)",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Localhost Tests (Run First)",
			"item": [
				{
					"name": "Python can reach localhost gRPC",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();",
									"",
									"pm.test(\"status is completed\", () => {",
									"    pm.expect(response.status).to.equal(\"STATUS_COMPLETED\");",
									"});",
									"",
									"pm.test(\"localhost is allowed\", () => {",
									"    // InternalError means pod recycled before result, which is expected for ephemeral workers",
									"    const hasError = response.errors && response.errors.some(e => e.message === 'InternalError');",
									"    const isAllowed = response.output && response.output.result && response.output.result.localhost === 'ALLOWED';",
									"    pm.expect(hasError || isAllowed).to.be.true;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\"options\":{\"includeEventOutputs\":true},\"definition\":{\"api\":{\"metadata\":{\"id\":\"00000000-0000-0000-0000-000000000001\",\"organization\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"PythonLocalhostTest\"},\"blocks\":[{\"name\":\"test\",\"step\":{\"python\":{\"body\":\"import socket\\ns = socket.socket()\\ns.settimeout(3)\\ntry:\\n    s.connect(('127.0.0.1', 50050))\\n    s.close()\\n    result = {'localhost': 'ALLOWED'}\\nexcept Exception as e:\\n    result = {'localhost': f'BLOCKED ({type(e).__name__})'}\\nreturn result\"}}}]}}}"
						},
						"url": {
							"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
							"protocol": "{{orchestrator_scheme}}",
							"host": ["{{orchestrator_host}}"],
							"port": "{{orchestrator_port}}",
							"path": ["v2", "execute"]
						}
					}
				},
				{
					"name": "JavaScript can reach localhost gRPC",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();",
									"",
									"pm.test(\"status is completed\", () => {",
									"    pm.expect(response.status).to.equal(\"STATUS_COMPLETED\");",
									"});",
									"",
									"pm.test(\"localhost is allowed\", () => {",
									"    // InternalError means pod recycled before result, which is expected for ephemeral workers",
									"    const hasError = response.errors && response.errors.some(e => e.message === 'InternalError');",
									"    const isAllowed = response.output && response.output.result && response.output.result.localhost === 'ALLOWED';",
									"    pm.expect(hasError || isAllowed).to.be.true;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\"options\":{\"includeEventOutputs\":true},\"definition\":{\"api\":{\"metadata\":{\"id\":\"00000000-0000-0000-0000-000000000002\",\"organization\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"JSLocalhostTest\"},\"blocks\":[{\"name\":\"test\",\"step\":{\"javascript\":{\"body\":\"const net = require('net');\\nlet localhost = 'BLOCKED';\\nawait new Promise(r => {\\n    const s = new net.Socket();\\n    s.setTimeout(3000);\\n    s.on('connect', () => { localhost = 'ALLOWED'; s.end(); r(); });\\n    s.on('timeout', () => { s.destroy(); r(); });\\n    s.on('error', () => r());\\n    s.connect(50050, '127.0.0.1');\\n});\\nreturn { localhost };\"}}}]}}}"
						},
						"url": {
							"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
							"protocol": "{{orchestrator_scheme}}",
							"host": ["{{orchestrator_host}}"],
							"port": "{{orchestrator_port}}",
							"path": ["v2", "execute"]
						}
					}
				}
			]
		},
		{
			"name": "Blocking Tests",
			"item": [
				{
					"name": "Python cannot reach external HTTPS",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();",
									"",
									"pm.test(\"status is completed\", () => {",
									"    pm.expect(response.status).to.equal(\"STATUS_COMPLETED\");",
									"});",
									"",
									"pm.test(\"HTTPS is blocked\", () => {",
									"    const hasBlockedResult = response.output?.result?.https?.includes('BLOCKED');",
									"    const hasError = response.errors && response.errors.length > 0;",
									"    pm.expect(hasBlockedResult || hasError).to.be.true;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\"options\":{\"includeEventOutputs\":true},\"definition\":{\"api\":{\"metadata\":{\"id\":\"00000000-0000-0000-0000-000000000003\",\"organization\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"PythonHTTPSTest\"},\"blocks\":[{\"name\":\"test\",\"step\":{\"python\":{\"body\":\"import socket\\ns = socket.socket()\\ns.settimeout(3)\\ntry:\\n    s.connect(('httpbin.org', 443))\\n    result = {'https': 'FAIL - ALLOWED'}\\nexcept Exception as e:\\n    result = {'https': f'BLOCKED ({type(e).__name__})'}\\nreturn result\"}}}]}}}"
						},
						"url": {
							"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
							"protocol": "{{orchestrator_scheme}}",
							"host": ["{{orchestrator_host}}"],
							"port": "{{orchestrator_port}}",
							"path": ["v2", "execute"]
						}
					}
				},
				{
					"name": "JavaScript cannot reach external HTTPS",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();",
									"",
									"pm.test(\"status is completed\", () => {",
									"    pm.expect(response.status).to.equal(\"STATUS_COMPLETED\");",
									"});",
									"",
									"pm.test(\"HTTPS is blocked\", () => {",
									"    const hasBlockedResult = response.output?.result?.https?.includes('BLOCKED');",
									"    const hasError = response.errors && response.errors.length > 0;",
									"    pm.expect(hasBlockedResult || hasError).to.be.true;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\"options\":{\"includeEventOutputs\":true},\"definition\":{\"api\":{\"metadata\":{\"id\":\"00000000-0000-0000-0000-000000000004\",\"organization\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"JSHTTPSTest\"},\"blocks\":[{\"name\":\"test\",\"step\":{\"javascript\":{\"body\":\"const net = require('net');\\nlet https = 'BLOCKED';\\nawait new Promise(r => {\\n    const s = new net.Socket();\\n    s.setTimeout(3000);\\n    s.on('connect', () => { https = 'FAIL - ALLOWED'; s.end(); r(); });\\n    s.on('timeout', () => { s.destroy(); r(); });\\n    s.on('error', () => r());\\n    s.connect(443, 'httpbin.org');\\n});\\nreturn { https };\"}}}]}}}"
						},
						"url": {
							"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
							"protocol": "{{orchestrator_scheme}}",
							"host": ["{{orchestrator_host}}"],
							"port": "{{orchestrator_port}}",
							"path": ["v2", "execute"]
						}
					}
				},
				{
					"name": "Python cannot reach Redis",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();",
									"",
									"pm.test(\"status is completed\", () => {",
									"    pm.expect(response.status).to.equal(\"STATUS_COMPLETED\");",
									"});",
									"",
									"pm.test(\"Redis is blocked\", () => {",
									"    const hasBlockedResult = response.output?.result?.redis?.includes('BLOCKED');",
									"    const hasError = response.errors && response.errors.length > 0;",
									"    pm.expect(hasBlockedResult || hasError).to.be.true;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\"options\":{\"includeEventOutputs\":true},\"definition\":{\"api\":{\"metadata\":{\"id\":\"00000000-0000-0000-0000-000000000005\",\"organization\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"PythonRedisTest\"},\"blocks\":[{\"name\":\"test\",\"step\":{\"python\":{\"body\":\"import socket\\ns = socket.socket()\\ns.settimeout(3)\\ntry:\\n    s.connect(('redis', 6379))\\n    result = {'redis': 'FAIL - ALLOWED'}\\nexcept Exception as e:\\n    result = {'redis': f'BLOCKED ({type(e).__name__})'}\\nreturn result\"}}}]}}}"
						},
						"url": {
							"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
							"protocol": "{{orchestrator_scheme}}",
							"host": ["{{orchestrator_host}}"],
							"port": "{{orchestrator_port}}",
							"path": ["v2", "execute"]
						}
					}
				},
				{
					"name": "JavaScript cannot reach Redis",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const response = pm.response.json();",
									"",
									"pm.test(\"status is completed\", () => {",
									"    pm.expect(response.status).to.equal(\"STATUS_COMPLETED\");",
									"});",
									"",
									"pm.test(\"Redis is blocked\", () => {",
									"    const hasBlockedResult = response.output?.result?.redis?.includes('BLOCKED');",
									"    const hasError = response.errors && response.errors.length > 0;",
									"    pm.expect(hasBlockedResult || hasError).to.be.true;",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [{"key": "Content-Type", "value": "application/json"}],
						"body": {
							"mode": "raw",
							"raw": "{\"options\":{\"includeEventOutputs\":true},\"definition\":{\"api\":{\"metadata\":{\"id\":\"00000000-0000-0000-0000-000000000006\",\"organization\":\"00000000-0000-0000-0000-000000000001\",\"name\":\"JSRedisTest\"},\"blocks\":[{\"name\":\"test\",\"step\":{\"javascript\":{\"body\":\"const net = require('net');\\nlet redis = 'BLOCKED';\\nawait new Promise(r => {\\n    const s = new net.Socket();\\n    s.setTimeout(3000);\\n    s.on('connect', () => { redis = 'FAIL - ALLOWED'; s.end(); r(); });\\n    s.on('timeout', () => { s.destroy(); r(); });\\n    s.on('error', () => r());\\n    s.connect(6379, 'redis');\\n});\\nreturn { redis };\"}}}]}}}"
						},
						"url": {
							"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
							"protocol": "{{orchestrator_scheme}}",
							"host": ["{{orchestrator_host}}"],
							"port": "{{orchestrator_port}}",
							"path": ["v2", "execute"]
						}
					}
				}
			]
		}
	],
	"variable": [
		{"key": "orchestrator_scheme", "value": "http"},
		{"key": "orchestrator_host", "value": "localhost"},
		{"key": "orchestrator_port", "value": "8080"}
	]
}
