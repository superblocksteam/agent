{
	"info": {
		"_postman_id": "ephemeral-worker-tests",
		"name": "Ephemeral Workers - Smokescreen Integration Tests",
		"description": "Tests for ephemeral worker sandbox network isolation via Smokescreen proxy.\n\nThese tests verify that sandboxes cannot reach internal infrastructure (Redis, orchestrator) when the proxy is enabled.\n\nNOTE: These tests use HTTP-based requests since smokescreen is an HTTP CONNECT proxy. Raw TCP socket connections are not intercepted.",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "javascript",
			"item": [
				{
					"name": "network isolation",
					"item": [
						{
							"name": "cannot reach redis via http",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const response = pm.response.json();",
											"",
											"pm.test('request completed', () => {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('connection to redis was blocked', () => {",
											"    // The step should fail because smokescreen blocks the connection",
											"    pm.expect(response.errors).to.not.be.undefined;",
											"    pm.expect(response.errors.length).to.be.greaterThan(0);",
											"    ",
											"    // Check that the error indicates connection was refused/blocked",
											"    const errorMsg = response.errors[0].message.toLowerCase();",
											"    const isBlocked = errorMsg.includes('econnrefused') ||",
											"                      errorMsg.includes('blocked') ||",
											"                      errorMsg.includes('forbidden') ||",
											"                      errorMsg.includes('proxy') ||",
											"                      errorMsg.includes('407') ||",
											"                      errorMsg.includes('parse error') ||",
											"                      errorMsg.includes('connect');",
											"    pm.expect(isBlocked).to.be.true;",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Superblocks-Authorization",
										"value": "Bearer {{superblocks_jwt}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"options\": {\n        \"include_events\": false\n    },\n    \"definition\": {\n        \"api\": {\n            \"metadata\": {\n                \"name\": \"redis http connection test\",\n                \"organization\": \"00000000-0000-0000-0000-000000000001\"\n            },\n            \"blocks\": [\n                {\n                    \"name\": \"Step1\",\n                    \"step\": {\n                        \"javascript\": {\n                            \"body\": \"const http = require('http');\\nreturn new Promise((resolve, reject) => {\\n    const req = http.get('http://redis:6379/', { timeout: 5000 }, (res) => {\\n        if (res.statusCode === 407) {\\n            reject(new Error('Blocked by proxy: 407 ' + res.statusMessage));\\n        } else {\\n            resolve('Connected to redis - THIS SHOULD NOT HAPPEN');\\n        }\\n    });\\n    req.on('error', (err) => reject(new Error('Connection blocked: ' + err.message)));\\n});\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
									"protocol": "{{orchestrator_scheme}}",
									"host": [
										"{{orchestrator_host}}"
									],
									"port": "{{orchestrator_port}}",
									"path": [
										"v2",
										"execute"
									]
								}
							},
							"response": []
						},
						{
							"name": "cannot reach orchestrator",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const response = pm.response.json();",
											"",
											"pm.test('request completed', () => {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('connection to orchestrator was blocked', () => {",
											"    // The step should fail because smokescreen blocks the connection",
											"    pm.expect(response.errors).to.not.be.undefined;",
											"    pm.expect(response.errors.length).to.be.greaterThan(0);",
											"    ",
											"    // Check that the error indicates connection was refused/blocked",
											"    const errorMsg = response.errors[0].message.toLowerCase();",
											"    const isBlocked = errorMsg.includes('econnrefused') ||",
											"                      errorMsg.includes('blocked') ||",
											"                      errorMsg.includes('forbidden') ||",
											"                      errorMsg.includes('proxy') ||",
											"                      errorMsg.includes('407') ||",
											"                      errorMsg.includes('parse error') ||",
											"                      errorMsg.includes('connect');",
											"    pm.expect(isBlocked).to.be.true;",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Superblocks-Authorization",
										"value": "Bearer {{superblocks_jwt}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"options\": {\n        \"include_events\": false\n    },\n    \"definition\": {\n        \"api\": {\n            \"metadata\": {\n                \"name\": \"orchestrator connection test\",\n                \"organization\": \"00000000-0000-0000-0000-000000000001\"\n            },\n            \"blocks\": [\n                {\n                    \"name\": \"Step1\",\n                    \"step\": {\n                        \"javascript\": {\n                            \"body\": \"const http = require('http');\\nreturn new Promise((resolve, reject) => {\\n    const req = http.get('http://agent:8080/health', { timeout: 5000 }, (res) => {\\n        if (res.statusCode === 407) {\\n            reject(new Error('Blocked by proxy: 407 ' + res.statusMessage));\\n        } else {\\n            resolve('Connected to orchestrator - THIS SHOULD NOT HAPPEN');\\n        }\\n    });\\n    req.on('error', (err) => reject(new Error('Connection blocked: ' + err.message)));\\n});\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
									"protocol": "{{orchestrator_scheme}}",
									"host": [
										"{{orchestrator_host}}"
									],
									"port": "{{orchestrator_port}}",
									"path": [
										"v2",
										"execute"
									]
								}
							},
							"response": []
						},
						{
							"name": "can reach external hosts",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const response = pm.response.json();",
											"",
											"pm.test('request completed', () => {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('external connection succeeded', () => {",
											"    pm.expect(response.errors).to.be.undefined;",
											"    pm.expect(response.output).to.not.be.undefined;",
											"    pm.expect(response.output.result.toLowerCase()).to.include('example');",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Superblocks-Authorization",
										"value": "Bearer {{superblocks_jwt}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"options\": {\n        \"include_events\": false\n    },\n    \"definition\": {\n        \"api\": {\n            \"metadata\": {\n                \"name\": \"external connection test\",\n                \"organization\": \"00000000-0000-0000-0000-000000000001\"\n            },\n            \"blocks\": [\n                {\n                    \"name\": \"Step1\",\n                    \"step\": {\n                        \"javascript\": {\n                            \"body\": \"const https = require('https');\\nreturn new Promise((resolve, reject) => {\\n    https.get('https://example.com', { timeout: 10000 }, (res) => {\\n        let data = '';\\n        res.on('data', chunk => data += chunk);\\n        res.on('end', () => resolve(data.substring(0, 200)));\\n    }).on('error', reject);\\n});\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
									"protocol": "{{orchestrator_scheme}}",
									"host": [
										"{{orchestrator_host}}"
									],
									"port": "{{orchestrator_port}}",
									"path": [
										"v2",
										"execute"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "python",
			"item": [
				{
					"name": "network isolation",
					"item": [
						{
							"name": "cannot reach redis via http",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const response = pm.response.json();",
											"",
											"pm.test('request completed', () => {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('connection to redis was blocked', () => {",
											"    // The step should fail because smokescreen blocks the connection",
											"    pm.expect(response.errors).to.not.be.undefined;",
											"    pm.expect(response.errors.length).to.be.greaterThan(0);",
											"    ",
											"    // Check that the error indicates connection was refused/blocked",
											"    const errorMsg = response.errors[0].message.toLowerCase();",
											"    const isBlocked = errorMsg.includes('connection refused') ||",
											"                      errorMsg.includes('blocked') ||",
											"                      errorMsg.includes('forbidden') ||",
											"                      errorMsg.includes('proxy') ||",
											"                      errorMsg.includes('407') ||",
											"                      errorMsg.includes('urlopen') ||",
											"                      errorMsg.includes('errno');",
											"    pm.expect(isBlocked).to.be.true;",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Superblocks-Authorization",
										"value": "Bearer {{superblocks_jwt}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"options\": {\n        \"include_events\": false\n    },\n    \"definition\": {\n        \"api\": {\n            \"metadata\": {\n                \"name\": \"redis http connection test\",\n                \"organization\": \"00000000-0000-0000-0000-000000000001\"\n            },\n            \"blocks\": [\n                {\n                    \"name\": \"Step1\",\n                    \"step\": {\n                        \"python\": {\n                            \"body\": \"import urllib.request\\ntry:\\n    with urllib.request.urlopen('http://redis:6379/', timeout=5) as response:\\n        return 'Connected to redis - THIS SHOULD NOT HAPPEN'\\nexcept Exception as e:\\n    raise Exception(f'Connection blocked: {e}')\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
									"protocol": "{{orchestrator_scheme}}",
									"host": [
										"{{orchestrator_host}}"
									],
									"port": "{{orchestrator_port}}",
									"path": [
										"v2",
										"execute"
									]
								}
							},
							"response": []
						},
						{
							"name": "cannot reach orchestrator",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const response = pm.response.json();",
											"",
											"pm.test('request completed', () => {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('connection to orchestrator was blocked', () => {",
											"    // The step should fail because smokescreen blocks the connection",
											"    pm.expect(response.errors).to.not.be.undefined;",
											"    pm.expect(response.errors.length).to.be.greaterThan(0);",
											"    ",
											"    // Check that the error indicates connection was refused/blocked",
											"    const errorMsg = response.errors[0].message.toLowerCase();",
											"    const isBlocked = errorMsg.includes('connection refused') ||",
											"                      errorMsg.includes('blocked') ||",
											"                      errorMsg.includes('forbidden') ||",
											"                      errorMsg.includes('proxy') ||",
											"                      errorMsg.includes('407') ||",
											"                      errorMsg.includes('urlopen') ||",
											"                      errorMsg.includes('errno');",
											"    pm.expect(isBlocked).to.be.true;",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Superblocks-Authorization",
										"value": "Bearer {{superblocks_jwt}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"options\": {\n        \"include_events\": false\n    },\n    \"definition\": {\n        \"api\": {\n            \"metadata\": {\n                \"name\": \"orchestrator connection test\",\n                \"organization\": \"00000000-0000-0000-0000-000000000001\"\n            },\n            \"blocks\": [\n                {\n                    \"name\": \"Step1\",\n                    \"step\": {\n                        \"python\": {\n                            \"body\": \"import urllib.request\\ntry:\\n    with urllib.request.urlopen('http://agent:8080/health', timeout=5) as response:\\n        return 'Connected to orchestrator - THIS SHOULD NOT HAPPEN'\\nexcept Exception as e:\\n    raise Exception(f'Connection blocked: {e}')\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
									"protocol": "{{orchestrator_scheme}}",
									"host": [
										"{{orchestrator_host}}"
									],
									"port": "{{orchestrator_port}}",
									"path": [
										"v2",
										"execute"
									]
								}
							},
							"response": []
						},
						{
							"name": "can reach external hosts",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"const response = pm.response.json();",
											"",
											"pm.test('request completed', () => {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('external connection succeeded', () => {",
											"    pm.expect(response.errors).to.be.undefined;",
											"    pm.expect(response.output).to.not.be.undefined;",
											"    pm.expect(response.output.result).to.include('Example');",
											"});"
										],
										"type": "text/javascript"
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "X-Superblocks-Authorization",
										"value": "Bearer {{superblocks_jwt}}"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n    \"options\": {\n        \"include_events\": false\n    },\n    \"definition\": {\n        \"api\": {\n            \"metadata\": {\n                \"name\": \"external connection test\",\n                \"organization\": \"00000000-0000-0000-0000-000000000001\"\n            },\n            \"blocks\": [\n                {\n                    \"name\": \"Step1\",\n                    \"step\": {\n                        \"python\": {\n                            \"body\": \"import urllib.request\\nwith urllib.request.urlopen('https://example.com', timeout=10) as response:\\n    return response.read().decode('utf-8')[:200]\"\n                        }\n                    }\n                }\n            ]\n        }\n    }\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{orchestrator_scheme}}://{{orchestrator_host}}:{{orchestrator_port}}/v2/execute",
									"protocol": "{{orchestrator_scheme}}",
									"host": [
										"{{orchestrator_host}}"
									],
									"port": "{{orchestrator_port}}",
									"path": [
										"v2",
										"execute"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		}
	],
	"variable": [
		{
			"key": "orchestrator_scheme",
			"value": "http"
		},
		{
			"key": "orchestrator_host",
			"value": "localhost"
		},
		{
			"key": "orchestrator_port",
			"value": "8080"
		}
	]
}
