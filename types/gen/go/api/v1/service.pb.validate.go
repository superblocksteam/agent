// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/v1/service.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	v1 "github.com/superblocksteam/agent/types/gen/go/common/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = v1.UserType(0)
)

// define the regex for a UUID once up-front
var _service_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// Validate checks the field values on HealthRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HealthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HealthRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HealthRequestMultiError, or
// nil if none found.
func (m *HealthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HealthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Detailed

	if len(errors) > 0 {
		return HealthRequestMultiError(errors)
	}

	return nil
}

// HealthRequestMultiError is an error wrapping multiple validation errors
// returned by HealthRequest.ValidateAll() if the designated constraints
// aren't met.
type HealthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HealthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HealthRequestMultiError) AllErrors() []error { return m }

// HealthRequestValidationError is the validation error returned by
// HealthRequest.Validate if the designated constraints aren't met.
type HealthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HealthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HealthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HealthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HealthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HealthRequestValidationError) ErrorName() string { return "HealthRequestValidationError" }

// Error satisfies the builtin error interface
func (e HealthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHealthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HealthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HealthRequestValidationError{}

// Validate checks the field values on ValidateRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ValidateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ValidateRequestMultiError, or nil if none found.
func (m *ValidateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetApi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidateRequestValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidateRequestValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidateRequestValidationError{
				field:  "Api",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ValidateRequestMultiError(errors)
	}

	return nil
}

// ValidateRequestMultiError is an error wrapping multiple validation errors
// returned by ValidateRequest.ValidateAll() if the designated constraints
// aren't met.
type ValidateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateRequestMultiError) AllErrors() []error { return m }

// ValidateRequestValidationError is the validation error returned by
// ValidateRequest.Validate if the designated constraints aren't met.
type ValidateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateRequestValidationError) ErrorName() string { return "ValidateRequestValidationError" }

// Error satisfies the builtin error interface
func (e ValidateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateRequestValidationError{}

// Validate checks the field values on ExecuteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecuteRequestMultiError,
// or nil if none found.
func (m *ExecuteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetInputs()))
		i := 0
		for key := range m.GetInputs() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetInputs()[key]
			_ = val

			// no validation rules for Inputs[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, ExecuteRequestValidationError{
							field:  fmt.Sprintf("Inputs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, ExecuteRequestValidationError{
							field:  fmt.Sprintf("Inputs[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return ExecuteRequestValidationError{
						field:  fmt.Sprintf("Inputs[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequestValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetMocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  fmt.Sprintf("Mocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  fmt.Sprintf("Mocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequestValidationError{
					field:  fmt.Sprintf("Mocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	oneofRequestPresent := false
	switch v := m.Request.(type) {
	case *ExecuteRequest_Definition:
		if v == nil {
			err := ExecuteRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestPresent = true

		if all {
			switch v := interface{}(m.GetDefinition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  "Definition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  "Definition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDefinition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequestValidationError{
					field:  "Definition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ExecuteRequest_Fetch_:
		if v == nil {
			err := ExecuteRequestValidationError{
				field:  "Request",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofRequestPresent = true

		if all {
			switch v := interface{}(m.GetFetch()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  "Fetch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteRequestValidationError{
						field:  "Fetch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFetch()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteRequestValidationError{
					field:  "Fetch",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofRequestPresent {
		err := ExecuteRequestValidationError{
			field:  "Request",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExecuteRequestMultiError(errors)
	}

	return nil
}

// ExecuteRequestMultiError is an error wrapping multiple validation errors
// returned by ExecuteRequest.ValidateAll() if the designated constraints
// aren't met.
type ExecuteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequestMultiError) AllErrors() []error { return m }

// ExecuteRequestValidationError is the validation error returned by
// ExecuteRequest.Validate if the designated constraints aren't met.
type ExecuteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequestValidationError) ErrorName() string { return "ExecuteRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExecuteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequestValidationError{}

// Validate checks the field values on Definition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Definition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Definition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DefinitionMultiError, or
// nil if none found.
func (m *Definition) ValidateAll() error {
	return m.validate(true)
}

func (m *Definition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApi() == nil {
		err := DefinitionValidationError{
			field:  "Api",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetApi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefinitionValidationError{
				field:  "Api",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetIntegrations()))
		i := 0
		for key := range m.GetIntegrations() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetIntegrations()[key]
			_ = val

			// no validation rules for Integrations[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, DefinitionValidationError{
							field:  fmt.Sprintf("Integrations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, DefinitionValidationError{
							field:  fmt.Sprintf("Integrations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return DefinitionValidationError{
						field:  fmt.Sprintf("Integrations[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefinitionValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStores()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "Stores",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DefinitionValidationError{
					field:  "Stores",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStores()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DefinitionValidationError{
				field:  "Stores",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DefinitionMultiError(errors)
	}

	return nil
}

// DefinitionMultiError is an error wrapping multiple validation errors
// returned by Definition.ValidateAll() if the designated constraints aren't met.
type DefinitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DefinitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DefinitionMultiError) AllErrors() []error { return m }

// DefinitionValidationError is the validation error returned by
// Definition.Validate if the designated constraints aren't met.
type DefinitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DefinitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DefinitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DefinitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DefinitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DefinitionValidationError) ErrorName() string { return "DefinitionValidationError" }

// Error satisfies the builtin error interface
func (e DefinitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefinition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DefinitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DefinitionValidationError{}

// Validate checks the field values on StatusRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StatusRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StatusRequestMultiError, or
// nil if none found.
func (m *StatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Execution

	if len(errors) > 0 {
		return StatusRequestMultiError(errors)
	}

	return nil
}

// StatusRequestMultiError is an error wrapping multiple validation errors
// returned by StatusRequest.ValidateAll() if the designated constraints
// aren't met.
type StatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatusRequestMultiError) AllErrors() []error { return m }

// StatusRequestValidationError is the validation error returned by
// StatusRequest.Validate if the designated constraints aren't met.
type StatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatusRequestValidationError) ErrorName() string { return "StatusRequestValidationError" }

// Error satisfies the builtin error interface
func (e StatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatusRequestValidationError{}

// Validate checks the field values on AwaitResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AwaitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AwaitResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AwaitResponseMultiError, or
// nil if none found.
func (m *AwaitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AwaitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Execution

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AwaitResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AwaitResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AwaitResponseValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetErrors() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AwaitResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AwaitResponseValidationError{
						field:  fmt.Sprintf("Errors[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AwaitResponseValidationError{
					field:  fmt.Sprintf("Errors[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Status

	if all {
		switch v := interface{}(m.GetPerformance()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AwaitResponseValidationError{
					field:  "Performance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AwaitResponseValidationError{
					field:  "Performance",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPerformance()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AwaitResponseValidationError{
				field:  "Performance",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AwaitResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AwaitResponseValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AwaitResponseValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AwaitResponseMultiError(errors)
	}

	return nil
}

// AwaitResponseMultiError is an error wrapping multiple validation errors
// returned by AwaitResponse.ValidateAll() if the designated constraints
// aren't met.
type AwaitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AwaitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AwaitResponseMultiError) AllErrors() []error { return m }

// AwaitResponseValidationError is the validation error returned by
// AwaitResponse.Validate if the designated constraints aren't met.
type AwaitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AwaitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AwaitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AwaitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AwaitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AwaitResponseValidationError) ErrorName() string { return "AwaitResponseValidationError" }

// Error satisfies the builtin error interface
func (e AwaitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAwaitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AwaitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AwaitResponseValidationError{}

// Validate checks the field values on AsyncResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AsyncResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AsyncResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AsyncResponseMultiError, or
// nil if none found.
func (m *AsyncResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AsyncResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Execution

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AsyncResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AsyncResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AsyncResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AsyncResponseMultiError(errors)
	}

	return nil
}

// AsyncResponseMultiError is an error wrapping multiple validation errors
// returned by AsyncResponse.ValidateAll() if the designated constraints
// aren't met.
type AsyncResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AsyncResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AsyncResponseMultiError) AllErrors() []error { return m }

// AsyncResponseValidationError is the validation error returned by
// AsyncResponse.Validate if the designated constraints aren't met.
type AsyncResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AsyncResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AsyncResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AsyncResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AsyncResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AsyncResponseValidationError) ErrorName() string { return "AsyncResponseValidationError" }

// Error satisfies the builtin error interface
func (e AsyncResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAsyncResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AsyncResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AsyncResponseValidationError{}

// Validate checks the field values on StreamResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamResponseMultiError,
// or nil if none found.
func (m *StreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Execution

	if all {
		switch v := interface{}(m.GetEvent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Event",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Event",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEvent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StreamResponseValidationError{
				field:  "Event",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StreamResponseMultiError(errors)
	}

	return nil
}

// StreamResponseMultiError is an error wrapping multiple validation errors
// returned by StreamResponse.ValidateAll() if the designated constraints
// aren't met.
type StreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamResponseMultiError) AllErrors() []error { return m }

// StreamResponseValidationError is the validation error returned by
// StreamResponse.Validate if the designated constraints aren't met.
type StreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamResponseValidationError) ErrorName() string { return "StreamResponseValidationError" }

// Error satisfies the builtin error interface
func (e StreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamResponseValidationError{}

// Validate checks the field values on OutputRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OutputRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutputRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OutputRequestMultiError, or
// nil if none found.
func (m *OutputRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *OutputRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if err := m._validateUuid(m.GetExecution()); err != nil {
		err = OutputRequestValidationError{
			field:  "Execution",
			reason: "value must be a valid UUID",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetBlock()) < 1 {
		err := OutputRequestValidationError{
			field:  "Block",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return OutputRequestMultiError(errors)
	}

	return nil
}

func (m *OutputRequest) _validateUuid(uuid string) error {
	if matched := _service_uuidPattern.MatchString(uuid); !matched {
		return errors.New("invalid uuid format")
	}

	return nil
}

// OutputRequestMultiError is an error wrapping multiple validation errors
// returned by OutputRequest.ValidateAll() if the designated constraints
// aren't met.
type OutputRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutputRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutputRequestMultiError) AllErrors() []error { return m }

// OutputRequestValidationError is the validation error returned by
// OutputRequest.Validate if the designated constraints aren't met.
type OutputRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutputRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutputRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutputRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutputRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutputRequestValidationError) ErrorName() string { return "OutputRequestValidationError" }

// Error satisfies the builtin error interface
func (e OutputRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutputRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutputRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutputRequestValidationError{}

// Validate checks the field values on OutputResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OutputResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutputResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OutputResponseMultiError,
// or nil if none found.
func (m *OutputResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *OutputResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutputResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutputResponseValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutputResponseValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutputResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutputResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutputResponseValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, OutputResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, OutputResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return OutputResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return OutputResponseMultiError(errors)
	}

	return nil
}

// OutputResponseMultiError is an error wrapping multiple validation errors
// returned by OutputResponse.ValidateAll() if the designated constraints
// aren't met.
type OutputResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutputResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutputResponseMultiError) AllErrors() []error { return m }

// OutputResponseValidationError is the validation error returned by
// OutputResponse.Validate if the designated constraints aren't met.
type OutputResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutputResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutputResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutputResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutputResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutputResponseValidationError) ErrorName() string { return "OutputResponseValidationError" }

// Error satisfies the builtin error interface
func (e OutputResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutputResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutputResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutputResponseValidationError{}

// Validate checks the field values on CancelRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CancelRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CancelRequestMultiError, or
// nil if none found.
func (m *CancelRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Execution

	if len(errors) > 0 {
		return CancelRequestMultiError(errors)
	}

	return nil
}

// CancelRequestMultiError is an error wrapping multiple validation errors
// returned by CancelRequest.ValidateAll() if the designated constraints
// aren't met.
type CancelRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelRequestMultiError) AllErrors() []error { return m }

// CancelRequestValidationError is the validation error returned by
// CancelRequest.Validate if the designated constraints aren't met.
type CancelRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelRequestValidationError) ErrorName() string { return "CancelRequestValidationError" }

// Error satisfies the builtin error interface
func (e CancelRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelRequestValidationError{}

// Validate checks the field values on CancelResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CancelResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CancelResponseMultiError,
// or nil if none found.
func (m *CancelResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelResponseMultiError(errors)
	}

	return nil
}

// CancelResponseMultiError is an error wrapping multiple validation errors
// returned by CancelResponse.ValidateAll() if the designated constraints
// aren't met.
type CancelResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelResponseMultiError) AllErrors() []error { return m }

// CancelResponseValidationError is the validation error returned by
// CancelResponse.Validate if the designated constraints aren't met.
type CancelResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelResponseValidationError) ErrorName() string { return "CancelResponseValidationError" }

// Error satisfies the builtin error interface
func (e CancelResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelResponseValidationError{}

// Validate checks the field values on TestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestRequestMultiError, or
// nil if none found.
func (m *TestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDatasourceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatasourceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRequestValidationError{
				field:  "DatasourceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IntegrationType

	// no validation rules for ConfigurationId

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRequestValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.ActionConfig != nil {

		if all {
			switch v := interface{}(m.GetActionConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TestRequestValidationError{
						field:  "ActionConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TestRequestValidationError{
						field:  "ActionConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActionConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TestRequestValidationError{
					field:  "ActionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TestRequestMultiError(errors)
	}

	return nil
}

// TestRequestMultiError is an error wrapping multiple validation errors
// returned by TestRequest.ValidateAll() if the designated constraints aren't met.
type TestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRequestMultiError) AllErrors() []error { return m }

// TestRequestValidationError is the validation error returned by
// TestRequest.Validate if the designated constraints aren't met.
type TestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRequestValidationError) ErrorName() string { return "TestRequestValidationError" }

// Error satisfies the builtin error interface
func (e TestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRequestValidationError{}

// Validate checks the field values on TestResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestResponseMultiError, or
// nil if none found.
func (m *TestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TestResponseMultiError(errors)
	}

	return nil
}

// TestResponseMultiError is an error wrapping multiple validation errors
// returned by TestResponse.ValidateAll() if the designated constraints aren't met.
type TestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestResponseMultiError) AllErrors() []error { return m }

// TestResponseValidationError is the validation error returned by
// TestResponse.Validate if the designated constraints aren't met.
type TestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestResponseValidationError) ErrorName() string { return "TestResponseValidationError" }

// Error satisfies the builtin error interface
func (e TestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestResponseValidationError{}

// Validate checks the field values on DeleteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteRequestMultiError, or
// nil if none found.
func (m *DeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Integration

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRequestValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ConfigurationId

	// no validation rules for PluginName

	if len(errors) > 0 {
		return DeleteRequestMultiError(errors)
	}

	return nil
}

// DeleteRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRequestMultiError) AllErrors() []error { return m }

// DeleteRequestValidationError is the validation error returned by
// DeleteRequest.Validate if the designated constraints aren't met.
type DeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRequestValidationError) ErrorName() string { return "DeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRequestValidationError{}

// Validate checks the field values on DeleteResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteResponseMultiError,
// or nil if none found.
func (m *DeleteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteResponseMultiError(errors)
	}

	return nil
}

// DeleteResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteResponseMultiError) AllErrors() []error { return m }

// DeleteResponseValidationError is the validation error returned by
// DeleteResponse.Validate if the designated constraints aren't met.
type DeleteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteResponseValidationError) ErrorName() string { return "DeleteResponseValidationError" }

// Error satisfies the builtin error interface
func (e DeleteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteResponseValidationError{}

// Validate checks the field values on Function with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Function) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Function with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FunctionMultiError, or nil
// if none found.
func (m *Function) ValidateAll() error {
	return m.validate(true)
}

func (m *Function) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FunctionMultiError(errors)
	}

	return nil
}

// FunctionMultiError is an error wrapping multiple validation errors returned
// by Function.ValidateAll() if the designated constraints aren't met.
type FunctionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FunctionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FunctionMultiError) AllErrors() []error { return m }

// FunctionValidationError is the validation error returned by
// Function.Validate if the designated constraints aren't met.
type FunctionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FunctionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FunctionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FunctionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FunctionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FunctionValidationError) ErrorName() string { return "FunctionValidationError" }

// Error satisfies the builtin error interface
func (e FunctionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFunction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FunctionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FunctionValidationError{}

// Validate checks the field values on TwoWayRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TwoWayRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TwoWayRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TwoWayRequestMultiError, or
// nil if none found.
func (m *TwoWayRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TwoWayRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *TwoWayRequest_Execute:
		if v == nil {
			err := TwoWayRequestValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExecute()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TwoWayRequestValidationError{
						field:  "Execute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TwoWayRequestValidationError{
						field:  "Execute",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExecute()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TwoWayRequestValidationError{
					field:  "Execute",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TwoWayRequest_Function:
		if v == nil {
			err := TwoWayRequestValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFunction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TwoWayRequestValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TwoWayRequestValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFunction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TwoWayRequestValidationError{
					field:  "Function",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TwoWayRequestMultiError(errors)
	}

	return nil
}

// TwoWayRequestMultiError is an error wrapping multiple validation errors
// returned by TwoWayRequest.ValidateAll() if the designated constraints
// aren't met.
type TwoWayRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TwoWayRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TwoWayRequestMultiError) AllErrors() []error { return m }

// TwoWayRequestValidationError is the validation error returned by
// TwoWayRequest.Validate if the designated constraints aren't met.
type TwoWayRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TwoWayRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TwoWayRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TwoWayRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TwoWayRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TwoWayRequestValidationError) ErrorName() string { return "TwoWayRequestValidationError" }

// Error satisfies the builtin error interface
func (e TwoWayRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTwoWayRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TwoWayRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TwoWayRequestValidationError{}

// Validate checks the field values on TwoWayResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TwoWayResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TwoWayResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TwoWayResponseMultiError,
// or nil if none found.
func (m *TwoWayResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *TwoWayResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *TwoWayResponse_Stream:
		if v == nil {
			err := TwoWayResponseValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TwoWayResponseValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TwoWayResponseValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TwoWayResponseValidationError{
					field:  "Stream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *TwoWayResponse_Function:
		if v == nil {
			err := TwoWayResponseValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFunction()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TwoWayResponseValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TwoWayResponseValidationError{
						field:  "Function",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFunction()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TwoWayResponseValidationError{
					field:  "Function",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TwoWayResponseMultiError(errors)
	}

	return nil
}

// TwoWayResponseMultiError is an error wrapping multiple validation errors
// returned by TwoWayResponse.ValidateAll() if the designated constraints
// aren't met.
type TwoWayResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TwoWayResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TwoWayResponseMultiError) AllErrors() []error { return m }

// TwoWayResponseValidationError is the validation error returned by
// TwoWayResponse.Validate if the designated constraints aren't met.
type TwoWayResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TwoWayResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TwoWayResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TwoWayResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TwoWayResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TwoWayResponseValidationError) ErrorName() string { return "TwoWayResponseValidationError" }

// Error satisfies the builtin error interface
func (e TwoWayResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTwoWayResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TwoWayResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TwoWayResponseValidationError{}

// Validate checks the field values on Mock with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Mock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mock with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in MockMultiError, or nil if none found.
func (m *Mock) ValidateAll() error {
	return m.validate(true)
}

func (m *Mock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MockValidationError{
					field:  "On",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MockValidationError{
					field:  "On",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MockValidationError{
				field:  "On",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReturn()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MockValidationError{
					field:  "Return",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MockValidationError{
					field:  "Return",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReturn()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MockValidationError{
				field:  "Return",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MockMultiError(errors)
	}

	return nil
}

// MockMultiError is an error wrapping multiple validation errors returned by
// Mock.ValidateAll() if the designated constraints aren't met.
type MockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MockMultiError) AllErrors() []error { return m }

// MockValidationError is the validation error returned by Mock.Validate if the
// designated constraints aren't met.
type MockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MockValidationError) ErrorName() string { return "MockValidationError" }

// Error satisfies the builtin error interface
func (e MockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MockValidationError{}

// Validate checks the field values on MetadataRequestDeprecated with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetadataRequestDeprecated) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataRequestDeprecated with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetadataRequestDeprecatedMultiError, or nil if none found.
func (m *MetadataRequestDeprecated) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataRequestDeprecated) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Integration

	// no validation rules for ApiId

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataRequestDeprecatedValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataRequestDeprecatedValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataRequestDeprecatedValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetadataRequestDeprecatedMultiError(errors)
	}

	return nil
}

// MetadataRequestDeprecatedMultiError is an error wrapping multiple validation
// errors returned by MetadataRequestDeprecated.ValidateAll() if the
// designated constraints aren't met.
type MetadataRequestDeprecatedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataRequestDeprecatedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataRequestDeprecatedMultiError) AllErrors() []error { return m }

// MetadataRequestDeprecatedValidationError is the validation error returned by
// MetadataRequestDeprecated.Validate if the designated constraints aren't met.
type MetadataRequestDeprecatedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataRequestDeprecatedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataRequestDeprecatedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataRequestDeprecatedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataRequestDeprecatedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataRequestDeprecatedValidationError) ErrorName() string {
	return "MetadataRequestDeprecatedValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataRequestDeprecatedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataRequestDeprecated.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataRequestDeprecatedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataRequestDeprecatedValidationError{}

// Validate checks the field values on MetadataRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetadataRequestMultiError, or nil if none found.
func (m *MetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Integration

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataRequestValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStepConfiguration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "StepConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "StepConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStepConfiguration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataRequestValidationError{
				field:  "StepConfiguration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return MetadataRequestMultiError(errors)
	}

	return nil
}

// MetadataRequestMultiError is an error wrapping multiple validation errors
// returned by MetadataRequest.ValidateAll() if the designated constraints
// aren't met.
type MetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataRequestMultiError) AllErrors() []error { return m }

// MetadataRequestValidationError is the validation error returned by
// MetadataRequest.Validate if the designated constraints aren't met.
type MetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataRequestValidationError) ErrorName() string { return "MetadataRequestValidationError" }

// Error satisfies the builtin error interface
func (e MetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataRequestValidationError{}

// Validate checks the field values on MetadataResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetadataResponseMultiError, or nil if none found.
func (m *MetadataResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GSheetsNextPageToken

	switch v := m.Metadata.(type) {
	case *MetadataResponse_DatabaseSchemaMetadata_:
		if v == nil {
			err := MetadataResponseValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDatabaseSchemaMetadata()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "DatabaseSchemaMetadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "DatabaseSchemaMetadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabaseSchemaMetadata()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponseValidationError{
					field:  "DatabaseSchemaMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetadataResponse_BucketsMetadata_:
		if v == nil {
			err := MetadataResponseValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBucketsMetadata()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "BucketsMetadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "BucketsMetadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBucketsMetadata()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponseValidationError{
					field:  "BucketsMetadata",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetadataResponse_Kafka:
		if v == nil {
			err := MetadataResponseValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponseValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetadataResponse_Cosmosdb:
		if v == nil {
			err := MetadataResponseValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCosmosdb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "Cosmosdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "Cosmosdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCosmosdb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponseValidationError{
					field:  "Cosmosdb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *MetadataResponse_Adls:
		if v == nil {
			err := MetadataResponseValidationError{
				field:  "Metadata",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAdls()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "Adls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponseValidationError{
						field:  "Adls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdls()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponseValidationError{
					field:  "Adls",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return MetadataResponseMultiError(errors)
	}

	return nil
}

// MetadataResponseMultiError is an error wrapping multiple validation errors
// returned by MetadataResponse.ValidateAll() if the designated constraints
// aren't met.
type MetadataResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponseMultiError) AllErrors() []error { return m }

// MetadataResponseValidationError is the validation error returned by
// MetadataResponse.Validate if the designated constraints aren't met.
type MetadataResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponseValidationError) ErrorName() string { return "MetadataResponseValidationError" }

// Error satisfies the builtin error interface
func (e MetadataResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponseValidationError{}

// Validate checks the field values on DownloadRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DownloadRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadRequestMultiError, or nil if none found.
func (m *DownloadRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Location

	if len(errors) > 0 {
		return DownloadRequestMultiError(errors)
	}

	return nil
}

// DownloadRequestMultiError is an error wrapping multiple validation errors
// returned by DownloadRequest.ValidateAll() if the designated constraints
// aren't met.
type DownloadRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadRequestMultiError) AllErrors() []error { return m }

// DownloadRequestValidationError is the validation error returned by
// DownloadRequest.Validate if the designated constraints aren't met.
type DownloadRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadRequestValidationError) ErrorName() string { return "DownloadRequestValidationError" }

// Error satisfies the builtin error interface
func (e DownloadRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadRequestValidationError{}

// Validate checks the field values on DownloadResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DownloadResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DownloadResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DownloadResponseMultiError, or nil if none found.
func (m *DownloadResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DownloadResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return DownloadResponseMultiError(errors)
	}

	return nil
}

// DownloadResponseMultiError is an error wrapping multiple validation errors
// returned by DownloadResponse.ValidateAll() if the designated constraints
// aren't met.
type DownloadResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadResponseMultiError) AllErrors() []error { return m }

// DownloadResponseValidationError is the validation error returned by
// DownloadResponse.Validate if the designated constraints aren't met.
type DownloadResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadResponseValidationError) ErrorName() string { return "DownloadResponseValidationError" }

// Error satisfies the builtin error interface
func (e DownloadResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadResponseValidationError{}

// Validate checks the field values on WorkflowResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WorkflowResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WorkflowResponseMultiError, or nil if none found.
func (m *WorkflowResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResponseMeta()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkflowResponseValidationError{
					field:  "ResponseMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkflowResponseValidationError{
					field:  "ResponseMeta",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponseMeta()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkflowResponseValidationError{
				field:  "ResponseMeta",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkflowResponseMultiError(errors)
	}

	return nil
}

// WorkflowResponseMultiError is an error wrapping multiple validation errors
// returned by WorkflowResponse.ValidateAll() if the designated constraints
// aren't met.
type WorkflowResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowResponseMultiError) AllErrors() []error { return m }

// WorkflowResponseValidationError is the validation error returned by
// WorkflowResponse.Validate if the designated constraints aren't met.
type WorkflowResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowResponseValidationError) ErrorName() string { return "WorkflowResponseValidationError" }

// Error satisfies the builtin error interface
func (e WorkflowResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowResponseValidationError{}

// Validate checks the field values on ExecuteRequest_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteRequest_OptionsMultiError, or nil if none found.
func (m *ExecuteRequest_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ExcludeOutput

	// no validation rules for IncludeEventOutputs

	// no validation rules for IncludeEvents

	// no validation rules for Start

	// no validation rules for Stop

	// no validation rules for IncludeResolved

	// no validation rules for Async

	// no validation rules for IncludeApiEvents

	if len(errors) > 0 {
		return ExecuteRequest_OptionsMultiError(errors)
	}

	return nil
}

// ExecuteRequest_OptionsMultiError is an error wrapping multiple validation
// errors returned by ExecuteRequest_Options.ValidateAll() if the designated
// constraints aren't met.
type ExecuteRequest_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequest_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequest_OptionsMultiError) AllErrors() []error { return m }

// ExecuteRequest_OptionsValidationError is the validation error returned by
// ExecuteRequest_Options.Validate if the designated constraints aren't met.
type ExecuteRequest_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequest_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequest_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequest_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequest_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequest_OptionsValidationError) ErrorName() string {
	return "ExecuteRequest_OptionsValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteRequest_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequest_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequest_OptionsValidationError{}

// Validate checks the field values on ExecuteRequest_Fetch with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest_Fetch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest_Fetch with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteRequest_FetchMultiError, or nil if none found.
func (m *ExecuteRequest_Fetch) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest_Fetch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetProfile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequest_FetchValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequest_FetchValidationError{
					field:  "Profile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequest_FetchValidationError{
				field:  "Profile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ViewMode

	if m.Test != nil {
		// no validation rules for Test
	}

	if m.Token != nil {
		// no validation rules for Token
	}

	if m.CommitId != nil {
		// no validation rules for CommitId
	}

	if m.BranchName != nil {
		// no validation rules for BranchName
	}

	if len(errors) > 0 {
		return ExecuteRequest_FetchMultiError(errors)
	}

	return nil
}

// ExecuteRequest_FetchMultiError is an error wrapping multiple validation
// errors returned by ExecuteRequest_Fetch.ValidateAll() if the designated
// constraints aren't met.
type ExecuteRequest_FetchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequest_FetchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequest_FetchMultiError) AllErrors() []error { return m }

// ExecuteRequest_FetchValidationError is the validation error returned by
// ExecuteRequest_Fetch.Validate if the designated constraints aren't met.
type ExecuteRequest_FetchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequest_FetchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequest_FetchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequest_FetchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequest_FetchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequest_FetchValidationError) ErrorName() string {
	return "ExecuteRequest_FetchValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteRequest_FetchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest_Fetch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequest_FetchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequest_FetchValidationError{}

// Validate checks the field values on ExecuteRequest_File with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest_File) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest_File with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteRequest_FileMultiError, or nil if none found.
func (m *ExecuteRequest_File) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest_File) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OriginalName

	// no validation rules for Buffer

	// no validation rules for Encoding

	// no validation rules for MimeType

	// no validation rules for Size

	if len(errors) > 0 {
		return ExecuteRequest_FileMultiError(errors)
	}

	return nil
}

// ExecuteRequest_FileMultiError is an error wrapping multiple validation
// errors returned by ExecuteRequest_File.ValidateAll() if the designated
// constraints aren't met.
type ExecuteRequest_FileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequest_FileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequest_FileMultiError) AllErrors() []error { return m }

// ExecuteRequest_FileValidationError is the validation error returned by
// ExecuteRequest_File.Validate if the designated constraints aren't met.
type ExecuteRequest_FileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequest_FileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequest_FileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequest_FileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequest_FileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequest_FileValidationError) ErrorName() string {
	return "ExecuteRequest_FileValidationError"
}

// Error satisfies the builtin error interface
func (e ExecuteRequest_FileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest_File.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequest_FileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequest_FileValidationError{}

// Validate checks the field values on Definition_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Definition_Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Definition_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Definition_MetadataMultiError, or nil if none found.
func (m *Definition_Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Definition_Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Requester

	// no validation rules for Profile

	// no validation rules for OrganizationPlan

	// no validation rules for OrganizationName

	if m.RequesterType != nil {
		// no validation rules for RequesterType
	}

	if len(errors) > 0 {
		return Definition_MetadataMultiError(errors)
	}

	return nil
}

// Definition_MetadataMultiError is an error wrapping multiple validation
// errors returned by Definition_Metadata.ValidateAll() if the designated
// constraints aren't met.
type Definition_MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Definition_MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Definition_MetadataMultiError) AllErrors() []error { return m }

// Definition_MetadataValidationError is the validation error returned by
// Definition_Metadata.Validate if the designated constraints aren't met.
type Definition_MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Definition_MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Definition_MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Definition_MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Definition_MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Definition_MetadataValidationError) ErrorName() string {
	return "Definition_MetadataValidationError"
}

// Error satisfies the builtin error interface
func (e Definition_MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDefinition_Metadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Definition_MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Definition_MetadataValidationError{}

// Validate checks the field values on Function_Request with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Function_Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Function_Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Function_RequestMultiError, or nil if none found.
func (m *Function_Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Function_Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	for idx, item := range m.GetParameters() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Function_RequestValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Function_RequestValidationError{
						field:  fmt.Sprintf("Parameters[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Function_RequestValidationError{
					field:  fmt.Sprintf("Parameters[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Function_RequestMultiError(errors)
	}

	return nil
}

// Function_RequestMultiError is an error wrapping multiple validation errors
// returned by Function_Request.ValidateAll() if the designated constraints
// aren't met.
type Function_RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Function_RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Function_RequestMultiError) AllErrors() []error { return m }

// Function_RequestValidationError is the validation error returned by
// Function_Request.Validate if the designated constraints aren't met.
type Function_RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Function_RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Function_RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Function_RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Function_RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Function_RequestValidationError) ErrorName() string { return "Function_RequestValidationError" }

// Error satisfies the builtin error interface
func (e Function_RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFunction_Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Function_RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Function_RequestValidationError{}

// Validate checks the field values on Function_Response with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Function_Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Function_Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Function_ResponseMultiError, or nil if none found.
func (m *Function_Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Function_Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Function_ResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Function_ResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Function_ResponseValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Function_ResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Function_ResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Function_ResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Function_ResponseMultiError(errors)
	}

	return nil
}

// Function_ResponseMultiError is an error wrapping multiple validation errors
// returned by Function_Response.ValidateAll() if the designated constraints
// aren't met.
type Function_ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Function_ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Function_ResponseMultiError) AllErrors() []error { return m }

// Function_ResponseValidationError is the validation error returned by
// Function_Response.Validate if the designated constraints aren't met.
type Function_ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Function_ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Function_ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Function_ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Function_ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Function_ResponseValidationError) ErrorName() string {
	return "Function_ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e Function_ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFunction_Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Function_ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Function_ResponseValidationError{}

// Validate checks the field values on Mock_Params with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Mock_Params) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mock_Params with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Mock_ParamsMultiError, or
// nil if none found.
func (m *Mock_Params) ValidateAll() error {
	return m.validate(true)
}

func (m *Mock_Params) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.IntegrationType != nil {
		// no validation rules for IntegrationType
	}

	if m.StepName != nil {
		// no validation rules for StepName
	}

	if m.Inputs != nil {

		if all {
			switch v := interface{}(m.GetInputs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Mock_ParamsValidationError{
						field:  "Inputs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Mock_ParamsValidationError{
						field:  "Inputs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInputs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Mock_ParamsValidationError{
					field:  "Inputs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Mock_ParamsMultiError(errors)
	}

	return nil
}

// Mock_ParamsMultiError is an error wrapping multiple validation errors
// returned by Mock_Params.ValidateAll() if the designated constraints aren't met.
type Mock_ParamsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Mock_ParamsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Mock_ParamsMultiError) AllErrors() []error { return m }

// Mock_ParamsValidationError is the validation error returned by
// Mock_Params.Validate if the designated constraints aren't met.
type Mock_ParamsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Mock_ParamsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Mock_ParamsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Mock_ParamsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Mock_ParamsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Mock_ParamsValidationError) ErrorName() string { return "Mock_ParamsValidationError" }

// Error satisfies the builtin error interface
func (e Mock_ParamsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMock_Params.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Mock_ParamsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Mock_ParamsValidationError{}

// Validate checks the field values on Mock_On with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Mock_On) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mock_On with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in Mock_OnMultiError, or nil if none found.
func (m *Mock_On) ValidateAll() error {
	return m.validate(true)
}

func (m *Mock_On) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Static != nil {

		if all {
			switch v := interface{}(m.GetStatic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Mock_OnValidationError{
						field:  "Static",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Mock_OnValidationError{
						field:  "Static",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Mock_OnValidationError{
					field:  "Static",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Dynamic != nil {
		// no validation rules for Dynamic
	}

	if len(errors) > 0 {
		return Mock_OnMultiError(errors)
	}

	return nil
}

// Mock_OnMultiError is an error wrapping multiple validation errors returned
// by Mock_On.ValidateAll() if the designated constraints aren't met.
type Mock_OnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Mock_OnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Mock_OnMultiError) AllErrors() []error { return m }

// Mock_OnValidationError is the validation error returned by Mock_On.Validate
// if the designated constraints aren't met.
type Mock_OnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Mock_OnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Mock_OnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Mock_OnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Mock_OnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Mock_OnValidationError) ErrorName() string { return "Mock_OnValidationError" }

// Error satisfies the builtin error interface
func (e Mock_OnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMock_On.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Mock_OnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Mock_OnValidationError{}

// Validate checks the field values on Mock_Return with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Mock_Return) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Mock_Return with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Mock_ReturnMultiError, or
// nil if none found.
func (m *Mock_Return) ValidateAll() error {
	return m.validate(true)
}

func (m *Mock_Return) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Type.(type) {
	case *Mock_Return_Static:
		if v == nil {
			err := Mock_ReturnValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStatic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Mock_ReturnValidationError{
						field:  "Static",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Mock_ReturnValidationError{
						field:  "Static",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Mock_ReturnValidationError{
					field:  "Static",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Mock_Return_Dynamic:
		if v == nil {
			err := Mock_ReturnValidationError{
				field:  "Type",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Dynamic
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return Mock_ReturnMultiError(errors)
	}

	return nil
}

// Mock_ReturnMultiError is an error wrapping multiple validation errors
// returned by Mock_Return.ValidateAll() if the designated constraints aren't met.
type Mock_ReturnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Mock_ReturnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Mock_ReturnMultiError) AllErrors() []error { return m }

// Mock_ReturnValidationError is the validation error returned by
// Mock_Return.Validate if the designated constraints aren't met.
type Mock_ReturnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Mock_ReturnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Mock_ReturnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Mock_ReturnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Mock_ReturnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Mock_ReturnValidationError) ErrorName() string { return "Mock_ReturnValidationError" }

// Error satisfies the builtin error interface
func (e Mock_ReturnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMock_Return.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Mock_ReturnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Mock_ReturnValidationError{}

// Validate checks the field values on MetadataResponse_DatabaseSchemaMetadata
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *MetadataResponse_DatabaseSchemaMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetadataResponse_DatabaseSchemaMetadata with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// MetadataResponse_DatabaseSchemaMetadataMultiError, or nil if none found.
func (m *MetadataResponse_DatabaseSchemaMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_DatabaseSchemaMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTables() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadataValidationError{
						field:  fmt.Sprintf("Tables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadataValidationError{
						field:  fmt.Sprintf("Tables[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponse_DatabaseSchemaMetadataValidationError{
					field:  fmt.Sprintf("Tables[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSchemas() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadataValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadataValidationError{
						field:  fmt.Sprintf("Schemas[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponse_DatabaseSchemaMetadataValidationError{
					field:  fmt.Sprintf("Schemas[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetadataResponse_DatabaseSchemaMetadataMultiError(errors)
	}

	return nil
}

// MetadataResponse_DatabaseSchemaMetadataMultiError is an error wrapping
// multiple validation errors returned by
// MetadataResponse_DatabaseSchemaMetadata.ValidateAll() if the designated
// constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_DatabaseSchemaMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_DatabaseSchemaMetadataMultiError) AllErrors() []error { return m }

// MetadataResponse_DatabaseSchemaMetadataValidationError is the validation
// error returned by MetadataResponse_DatabaseSchemaMetadata.Validate if the
// designated constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_DatabaseSchemaMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_DatabaseSchemaMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataResponse_DatabaseSchemaMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_DatabaseSchemaMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_DatabaseSchemaMetadataValidationError) ErrorName() string {
	return "MetadataResponse_DatabaseSchemaMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_DatabaseSchemaMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_DatabaseSchemaMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_DatabaseSchemaMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_DatabaseSchemaMetadataValidationError{}

// Validate checks the field values on MetadataResponse_BucketMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse_BucketMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataResponse_BucketMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetadataResponse_BucketMetadataMultiError, or nil if none found.
func (m *MetadataResponse_BucketMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_BucketMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return MetadataResponse_BucketMetadataMultiError(errors)
	}

	return nil
}

// MetadataResponse_BucketMetadataMultiError is an error wrapping multiple
// validation errors returned by MetadataResponse_BucketMetadata.ValidateAll()
// if the designated constraints aren't met.
type MetadataResponse_BucketMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_BucketMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_BucketMetadataMultiError) AllErrors() []error { return m }

// MetadataResponse_BucketMetadataValidationError is the validation error
// returned by MetadataResponse_BucketMetadata.Validate if the designated
// constraints aren't met.
type MetadataResponse_BucketMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_BucketMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_BucketMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataResponse_BucketMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_BucketMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_BucketMetadataValidationError) ErrorName() string {
	return "MetadataResponse_BucketMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_BucketMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_BucketMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_BucketMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_BucketMetadataValidationError{}

// Validate checks the field values on MetadataResponse_BucketsMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *MetadataResponse_BucketsMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataResponse_BucketsMetadata with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// MetadataResponse_BucketsMetadataMultiError, or nil if none found.
func (m *MetadataResponse_BucketsMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_BucketsMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBuckets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponse_BucketsMetadataValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponse_BucketsMetadataValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponse_BucketsMetadataValidationError{
					field:  fmt.Sprintf("Buckets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MetadataResponse_BucketsMetadataMultiError(errors)
	}

	return nil
}

// MetadataResponse_BucketsMetadataMultiError is an error wrapping multiple
// validation errors returned by
// MetadataResponse_BucketsMetadata.ValidateAll() if the designated
// constraints aren't met.
type MetadataResponse_BucketsMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_BucketsMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_BucketsMetadataMultiError) AllErrors() []error { return m }

// MetadataResponse_BucketsMetadataValidationError is the validation error
// returned by MetadataResponse_BucketsMetadata.Validate if the designated
// constraints aren't met.
type MetadataResponse_BucketsMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_BucketsMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_BucketsMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataResponse_BucketsMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_BucketsMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_BucketsMetadataValidationError) ErrorName() string {
	return "MetadataResponse_BucketsMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_BucketsMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_BucketsMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_BucketsMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_BucketsMetadataValidationError{}

// Validate checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Column with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse_DatabaseSchemaMetadata_Column) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Column with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetadataResponse_DatabaseSchemaMetadata_ColumnMultiError, or nil if none found.
func (m *MetadataResponse_DatabaseSchemaMetadata_Column) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_DatabaseSchemaMetadata_Column) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for EscapedName

	if len(errors) > 0 {
		return MetadataResponse_DatabaseSchemaMetadata_ColumnMultiError(errors)
	}

	return nil
}

// MetadataResponse_DatabaseSchemaMetadata_ColumnMultiError is an error
// wrapping multiple validation errors returned by
// MetadataResponse_DatabaseSchemaMetadata_Column.ValidateAll() if the
// designated constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_ColumnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_DatabaseSchemaMetadata_ColumnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_DatabaseSchemaMetadata_ColumnMultiError) AllErrors() []error { return m }

// MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError is the
// validation error returned by
// MetadataResponse_DatabaseSchemaMetadata_Column.Validate if the designated
// constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError) ErrorName() string {
	return "MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_DatabaseSchemaMetadata_Column.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_DatabaseSchemaMetadata_ColumnValidationError{}

// Validate checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Key with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse_DatabaseSchemaMetadata_Key) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Key with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MetadataResponse_DatabaseSchemaMetadata_KeyMultiError, or nil if none found.
func (m *MetadataResponse_DatabaseSchemaMetadata_Key) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_DatabaseSchemaMetadata_Key) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	if len(errors) > 0 {
		return MetadataResponse_DatabaseSchemaMetadata_KeyMultiError(errors)
	}

	return nil
}

// MetadataResponse_DatabaseSchemaMetadata_KeyMultiError is an error wrapping
// multiple validation errors returned by
// MetadataResponse_DatabaseSchemaMetadata_Key.ValidateAll() if the designated
// constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_DatabaseSchemaMetadata_KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_DatabaseSchemaMetadata_KeyMultiError) AllErrors() []error { return m }

// MetadataResponse_DatabaseSchemaMetadata_KeyValidationError is the validation
// error returned by MetadataResponse_DatabaseSchemaMetadata_Key.Validate if
// the designated constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_DatabaseSchemaMetadata_KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_DatabaseSchemaMetadata_KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataResponse_DatabaseSchemaMetadata_KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_DatabaseSchemaMetadata_KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_DatabaseSchemaMetadata_KeyValidationError) ErrorName() string {
	return "MetadataResponse_DatabaseSchemaMetadata_KeyValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_DatabaseSchemaMetadata_KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_DatabaseSchemaMetadata_Key.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_DatabaseSchemaMetadata_KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_DatabaseSchemaMetadata_KeyValidationError{}

// Validate checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Template with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse_DatabaseSchemaMetadata_Template) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Template with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetadataResponse_DatabaseSchemaMetadata_TemplateMultiError, or nil if none found.
func (m *MetadataResponse_DatabaseSchemaMetadata_Template) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_DatabaseSchemaMetadata_Template) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Title

	// no validation rules for Body

	if len(errors) > 0 {
		return MetadataResponse_DatabaseSchemaMetadata_TemplateMultiError(errors)
	}

	return nil
}

// MetadataResponse_DatabaseSchemaMetadata_TemplateMultiError is an error
// wrapping multiple validation errors returned by
// MetadataResponse_DatabaseSchemaMetadata_Template.ValidateAll() if the
// designated constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_TemplateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_DatabaseSchemaMetadata_TemplateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_DatabaseSchemaMetadata_TemplateMultiError) AllErrors() []error { return m }

// MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError is the
// validation error returned by
// MetadataResponse_DatabaseSchemaMetadata_Template.Validate if the designated
// constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError) ErrorName() string {
	return "MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_DatabaseSchemaMetadata_Template.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_DatabaseSchemaMetadata_TemplateValidationError{}

// Validate checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Table with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse_DatabaseSchemaMetadata_Table) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Table with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// MetadataResponse_DatabaseSchemaMetadata_TableMultiError, or nil if none found.
func (m *MetadataResponse_DatabaseSchemaMetadata_Table) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_DatabaseSchemaMetadata_Table) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Type

	// no validation rules for Name

	for idx, item := range m.GetColumns() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
						field:  fmt.Sprintf("Columns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
						field:  fmt.Sprintf("Columns[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
					field:  fmt.Sprintf("Columns[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
						field:  fmt.Sprintf("Keys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
						field:  fmt.Sprintf("Keys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
					field:  fmt.Sprintf("Keys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTemplates() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
						field:  fmt.Sprintf("Templates[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MetadataResponse_DatabaseSchemaMetadata_TableValidationError{
					field:  fmt.Sprintf("Templates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Schema

	if len(errors) > 0 {
		return MetadataResponse_DatabaseSchemaMetadata_TableMultiError(errors)
	}

	return nil
}

// MetadataResponse_DatabaseSchemaMetadata_TableMultiError is an error wrapping
// multiple validation errors returned by
// MetadataResponse_DatabaseSchemaMetadata_Table.ValidateAll() if the
// designated constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_TableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_DatabaseSchemaMetadata_TableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_DatabaseSchemaMetadata_TableMultiError) AllErrors() []error { return m }

// MetadataResponse_DatabaseSchemaMetadata_TableValidationError is the
// validation error returned by
// MetadataResponse_DatabaseSchemaMetadata_Table.Validate if the designated
// constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_TableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_DatabaseSchemaMetadata_TableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_DatabaseSchemaMetadata_TableValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetadataResponse_DatabaseSchemaMetadata_TableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_DatabaseSchemaMetadata_TableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_DatabaseSchemaMetadata_TableValidationError) ErrorName() string {
	return "MetadataResponse_DatabaseSchemaMetadata_TableValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_DatabaseSchemaMetadata_TableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_DatabaseSchemaMetadata_Table.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_DatabaseSchemaMetadata_TableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_DatabaseSchemaMetadata_TableValidationError{}

// Validate checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Schema with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *MetadataResponse_DatabaseSchemaMetadata_Schema) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// MetadataResponse_DatabaseSchemaMetadata_Schema with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// MetadataResponse_DatabaseSchemaMetadata_SchemaMultiError, or nil if none found.
func (m *MetadataResponse_DatabaseSchemaMetadata_Schema) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataResponse_DatabaseSchemaMetadata_Schema) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Name

	if len(errors) > 0 {
		return MetadataResponse_DatabaseSchemaMetadata_SchemaMultiError(errors)
	}

	return nil
}

// MetadataResponse_DatabaseSchemaMetadata_SchemaMultiError is an error
// wrapping multiple validation errors returned by
// MetadataResponse_DatabaseSchemaMetadata_Schema.ValidateAll() if the
// designated constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_SchemaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataResponse_DatabaseSchemaMetadata_SchemaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataResponse_DatabaseSchemaMetadata_SchemaMultiError) AllErrors() []error { return m }

// MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError is the
// validation error returned by
// MetadataResponse_DatabaseSchemaMetadata_Schema.Validate if the designated
// constraints aren't met.
type MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError) ErrorName() string {
	return "MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError"
}

// Error satisfies the builtin error interface
func (e MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataResponse_DatabaseSchemaMetadata_Schema.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataResponse_DatabaseSchemaMetadata_SchemaValidationError{}

// Validate checks the field values on WorkflowResponse_ResponseMeta with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WorkflowResponse_ResponseMeta) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkflowResponse_ResponseMeta with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// WorkflowResponse_ResponseMetaMultiError, or nil if none found.
func (m *WorkflowResponse_ResponseMeta) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkflowResponse_ResponseMeta) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Status

	// no validation rules for Message

	// no validation rules for Success

	if len(errors) > 0 {
		return WorkflowResponse_ResponseMetaMultiError(errors)
	}

	return nil
}

// WorkflowResponse_ResponseMetaMultiError is an error wrapping multiple
// validation errors returned by WorkflowResponse_ResponseMeta.ValidateAll()
// if the designated constraints aren't met.
type WorkflowResponse_ResponseMetaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkflowResponse_ResponseMetaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkflowResponse_ResponseMetaMultiError) AllErrors() []error { return m }

// WorkflowResponse_ResponseMetaValidationError is the validation error
// returned by WorkflowResponse_ResponseMeta.Validate if the designated
// constraints aren't met.
type WorkflowResponse_ResponseMetaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkflowResponse_ResponseMetaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkflowResponse_ResponseMetaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkflowResponse_ResponseMetaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkflowResponse_ResponseMetaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkflowResponse_ResponseMetaValidationError) ErrorName() string {
	return "WorkflowResponse_ResponseMetaValidationError"
}

// Error satisfies the builtin error interface
func (e WorkflowResponse_ResponseMetaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkflowResponse_ResponseMeta.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkflowResponse_ResponseMetaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkflowResponse_ResponseMetaValidationError{}
