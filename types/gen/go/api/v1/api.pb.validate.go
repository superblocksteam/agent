// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: api/v1/api.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Api with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Api) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Api with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ApiMultiError, or nil if none found.
func (m *Api) ValidateAll() error {
	return m.validate(true)
}

func (m *Api) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetMetadata() == nil {
		err := ApiValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApiValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApiValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApiValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApiValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApiValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApiValidationError{
					field:  fmt.Sprintf("Blocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTrigger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ApiValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ApiValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrigger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ApiValidationError{
				field:  "Trigger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Signature != nil {

		if all {
			switch v := interface{}(m.GetSignature()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ApiValidationError{
						field:  "Signature",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ApiValidationError{
						field:  "Signature",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSignature()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ApiValidationError{
					field:  "Signature",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ApiMultiError(errors)
	}

	return nil
}

// ApiMultiError is an error wrapping multiple validation errors returned by
// Api.ValidateAll() if the designated constraints aren't met.
type ApiMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApiMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApiMultiError) AllErrors() []error { return m }

// ApiValidationError is the validation error returned by Api.Validate if the
// designated constraints aren't met.
type ApiValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApiValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApiValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApiValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApiValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApiValidationError) ErrorName() string { return "ApiValidationError" }

// Error satisfies the builtin error interface
func (e ApiValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApi.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApiValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApiValidationError{}

// Validate checks the field values on Profiles with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Profiles) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Profiles with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProfilesMultiError, or nil
// if none found.
func (m *Profiles) ValidateAll() error {
	return m.validate(true)
}

func (m *Profiles) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetModes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProfilesValidationError{
					field:  "Modes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProfilesValidationError{
					field:  "Modes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetModes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProfilesValidationError{
				field:  "Modes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProfilesMultiError(errors)
	}

	return nil
}

// ProfilesMultiError is an error wrapping multiple validation errors returned
// by Profiles.ValidateAll() if the designated constraints aren't met.
type ProfilesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProfilesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProfilesMultiError) AllErrors() []error { return m }

// ProfilesValidationError is the validation error returned by
// Profiles.Validate if the designated constraints aren't met.
type ProfilesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProfilesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProfilesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProfilesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProfilesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProfilesValidationError) ErrorName() string { return "ProfilesValidationError" }

// Error satisfies the builtin error interface
func (e ProfilesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfiles.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProfilesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProfilesValidationError{}

// Validate checks the field values on Trigger with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Trigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TriggerMultiError, or nil if none found.
func (m *Trigger) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Config.(type) {
	case *Trigger_Application_:
		if v == nil {
			err := TriggerValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApplication()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TriggerValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TriggerValidationError{
						field:  "Application",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApplication()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TriggerValidationError{
					field:  "Application",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Trigger_Workflow_:
		if v == nil {
			err := TriggerValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetWorkflow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TriggerValidationError{
						field:  "Workflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TriggerValidationError{
						field:  "Workflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TriggerValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Trigger_Job_:
		if v == nil {
			err := TriggerValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetJob()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TriggerValidationError{
						field:  "Job",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TriggerValidationError{
						field:  "Job",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TriggerValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return TriggerMultiError(errors)
	}

	return nil
}

// TriggerMultiError is an error wrapping multiple validation errors returned
// by Trigger.ValidateAll() if the designated constraints aren't met.
type TriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerMultiError) AllErrors() []error { return m }

// TriggerValidationError is the validation error returned by Trigger.Validate
// if the designated constraints aren't met.
type TriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerValidationError) ErrorName() string { return "TriggerValidationError" }

// Error satisfies the builtin error interface
func (e TriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerValidationError{}

// Validate checks the field values on Blocks with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Blocks) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Blocks with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BlocksMultiError, or nil if none found.
func (m *Blocks) ValidateAll() error {
	return m.validate(true)
}

func (m *Blocks) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlocksValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlocksValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlocksValidationError{
					field:  fmt.Sprintf("Blocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BlocksMultiError(errors)
	}

	return nil
}

// BlocksMultiError is an error wrapping multiple validation errors returned by
// Blocks.ValidateAll() if the designated constraints aren't met.
type BlocksMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlocksMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlocksMultiError) AllErrors() []error { return m }

// BlocksValidationError is the validation error returned by Blocks.Validate if
// the designated constraints aren't met.
type BlocksValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlocksValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlocksValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlocksValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlocksValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlocksValidationError) ErrorName() string { return "BlocksValidationError" }

// Error satisfies the builtin error interface
func (e BlocksValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlocks.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlocksValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlocksValidationError{}

// Validate checks the field values on Block with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BlockMultiError, or nil if none found.
func (m *Block) ValidateAll() error {
	return m.validate(true)
}

func (m *Block) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := BlockValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *Block_Break_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetBreak()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Break",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Break",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBreak()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Break",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Return_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetReturn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Return",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Return",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReturn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Return",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Wait_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetWait()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Wait",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Wait",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWait()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Wait",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Parallel_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetParallel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Parallel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Parallel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetParallel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Parallel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Conditional_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetConditional()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Conditional",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Conditional",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConditional()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Conditional",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Loop_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetLoop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Loop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Loop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLoop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Loop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_TryCatch_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetTryCatch()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "TryCatch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "TryCatch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTryCatch()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "TryCatch",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Step:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetStep()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Step",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Step",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStep()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Step",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Variables:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetVariables()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Variables",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Variables",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetVariables()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Throw_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetThrow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Throw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Throw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetThrow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Throw",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Stream_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetStream()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Stream",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStream()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Stream",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Send_:
		if v == nil {
			err := BlockValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSend()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Send",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BlockValidationError{
						field:  "Send",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSend()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BlockValidationError{
					field:  "Send",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := BlockValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return BlockMultiError(errors)
	}

	return nil
}

// BlockMultiError is an error wrapping multiple validation errors returned by
// Block.ValidateAll() if the designated constraints aren't met.
type BlockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BlockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BlockMultiError) AllErrors() []error { return m }

// BlockValidationError is the validation error returned by Block.Validate if
// the designated constraints aren't met.
type BlockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BlockValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BlockValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BlockValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BlockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BlockValidationError) ErrorName() string { return "BlockValidationError" }

// Error satisfies the builtin error interface
func (e BlockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BlockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BlockValidationError{}

// Validate checks the field values on Step with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Step) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Step with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StepMultiError, or nil if none found.
func (m *Step) ValidateAll() error {
	return m.validate(true)
}

func (m *Step) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Integration

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *Step_Python:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetPython()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Python",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Python",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPython()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Python",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Bigquery:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetBigquery()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Bigquery",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Bigquery",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBigquery()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Bigquery",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Dynamodb:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetDynamodb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Dynamodb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Dynamodb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamodb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Dynamodb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Email:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetEmail()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Email",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEmail()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Email",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Graphql:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGraphql()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Graphql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Graphql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGraphql()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Graphql",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Graphqlintegration:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGraphqlintegration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Graphqlintegration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Graphqlintegration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGraphqlintegration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Graphqlintegration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Gsheets:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGsheets()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Gsheets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Gsheets",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGsheets()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Gsheets",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Mariadb:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetMariadb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mariadb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mariadb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMariadb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Mariadb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Mssql:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetMssql()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mssql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mssql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMssql()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Mssql",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Mysql:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetMysql()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mysql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mysql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMysql()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Mysql",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Postgres:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetPostgres()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Postgres",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Postgres",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPostgres()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Postgres",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Redshift:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetRedshift()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Redshift",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Redshift",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedshift()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Redshift",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Restapi:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetRestapi()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Restapi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Restapi",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRestapi()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Restapi",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Restapiintegration:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetRestapiintegration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Restapiintegration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Restapiintegration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRestapiintegration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Restapiintegration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Rockset:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetRockset()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Rockset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Rockset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRockset()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Rockset",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_S3:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetS3()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "S3",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetS3()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "S3",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Snowflake:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSnowflake()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Snowflake",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Snowflake",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSnowflake()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Snowflake",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Workflow:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetWorkflow()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Workflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Workflow",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetWorkflow()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Workflow",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Javascript:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetJavascript()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Javascript",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Javascript",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJavascript()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Javascript",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Mongodb:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetMongodb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mongodb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mongodb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMongodb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Mongodb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Gcs:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGcs()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Gcs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Gcs",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGcs()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Gcs",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Openai:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetOpenai()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Openai",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Openai",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOpenai()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Openai",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Ocr:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetOcr()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Ocr",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Ocr",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOcr()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Ocr",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Kafka:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Confluent:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetConfluent()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Confluent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Confluent",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetConfluent()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Confluent",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Msk:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetMsk()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Msk",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Msk",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMsk()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Msk",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Redpanda:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetRedpanda()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Redpanda",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Redpanda",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedpanda()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Redpanda",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Aivenkafka:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAivenkafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Aivenkafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Aivenkafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAivenkafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Aivenkafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Cockroachdb:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetCockroachdb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Cockroachdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Cockroachdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCockroachdb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Cockroachdb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Airtable:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAirtable()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Airtable",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Airtable",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAirtable()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Airtable",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Notion:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetNotion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Notion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Notion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNotion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Notion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Pagerduty:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetPagerduty()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Pagerduty",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Pagerduty",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPagerduty()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Pagerduty",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Sendgrid:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSendgrid()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Sendgrid",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSendgrid()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Sendgrid",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Slack:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSlack()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Slack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Slack",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSlack()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Slack",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Athena:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAthena()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Athena",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Athena",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAthena()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Athena",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Redis:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetRedis()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Redis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Redis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedis()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Redis",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Asana:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAsana()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Asana",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Asana",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAsana()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Asana",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Github:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGithub()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Github",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Github",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGithub()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Github",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Smtp:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSmtp()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Smtp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Smtp",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSmtp()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Smtp",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Salesforce:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSalesforce()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Salesforce",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Salesforce",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSalesforce()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Salesforce",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Bitbucket:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetBitbucket()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Bitbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Bitbucket",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBitbucket()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Bitbucket",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Circleci:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetCircleci()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Circleci",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Circleci",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCircleci()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Circleci",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Front:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetFront()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Front",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Front",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFront()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Front",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Intercom:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetIntercom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Intercom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Intercom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIntercom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Intercom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Segment:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetSegment()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Segment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Segment",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSegment()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Segment",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Launchdarkly:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetLaunchdarkly()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Launchdarkly",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Launchdarkly",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLaunchdarkly()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Launchdarkly",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Dropbox:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetDropbox()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Dropbox",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Dropbox",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDropbox()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Dropbox",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Twilio:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetTwilio()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Twilio",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Twilio",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTwilio()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Twilio",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Googledrive:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGoogledrive()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Googledrive",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Googledrive",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGoogledrive()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Googledrive",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Googleanalytics:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGoogleanalytics()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Googleanalytics",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Googleanalytics",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGoogleanalytics()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Googleanalytics",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Box:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetBox()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Box",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Box",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBox()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Box",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Hubspot:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetHubspot()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Hubspot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Hubspot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHubspot()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Hubspot",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Stripe:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetStripe()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Stripe",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Stripe",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStripe()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Stripe",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Zoom:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetZoom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Zoom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Zoom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZoom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Zoom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Jira:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetJira()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Jira",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Jira",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetJira()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Jira",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Zendesk:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetZendesk()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Zendesk",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Zendesk",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZendesk()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Zendesk",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Adls:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAdls()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Adls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Adls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdls()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Adls",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Pinecone:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetPinecone()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Pinecone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Pinecone",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPinecone()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Pinecone",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Cosmosdb:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetCosmosdb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Cosmosdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Cosmosdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCosmosdb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Cosmosdb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Datadog:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetDatadog()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Datadog",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Datadog",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatadog()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Datadog",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Xero:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetXero()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Xero",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Xero",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetXero()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Xero",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Oracledb:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetOracledb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Oracledb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Oracledb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOracledb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Oracledb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Elasticsearch:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetElasticsearch()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Elasticsearch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Elasticsearch",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetElasticsearch()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Elasticsearch",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Databricks:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetDatabricks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Databricks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Databricks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDatabricks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Databricks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Couchbase:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetCouchbase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Couchbase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Couchbase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCouchbase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Couchbase",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Custom:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetCustom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Custom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Custom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCustom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Custom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Anthropic:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetAnthropic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Anthropic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Anthropic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAnthropic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Anthropic",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Cohere:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetCohere()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Cohere",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Cohere",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCohere()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Cohere",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Fireworks:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetFireworks()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Fireworks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Fireworks",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFireworks()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Fireworks",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Mistral:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetMistral()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mistral",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Mistral",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMistral()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Mistral",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Groq:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGroq()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Groq",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Groq",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGroq()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Groq",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Perplexity:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetPerplexity()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Perplexity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Perplexity",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPerplexity()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Perplexity",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Stabilityai:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetStabilityai()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Stabilityai",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Stabilityai",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStabilityai()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Stabilityai",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Step_Gemini:
		if v == nil {
			err := StepValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetGemini()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Gemini",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StepValidationError{
						field:  "Gemini",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGemini()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StepValidationError{
					field:  "Gemini",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := StepValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return StepMultiError(errors)
	}

	return nil
}

// StepMultiError is an error wrapping multiple validation errors returned by
// Step.ValidateAll() if the designated constraints aren't met.
type StepMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StepMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StepMultiError) AllErrors() []error { return m }

// StepValidationError is the validation error returned by Step.Validate if the
// designated constraints aren't met.
type StepValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StepValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StepValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StepValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StepValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StepValidationError) ErrorName() string { return "StepValidationError" }

// Error satisfies the builtin error interface
func (e StepValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStep.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StepValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StepValidationError{}

// Validate checks the field values on Profiles_Modes with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Profiles_Modes) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Profiles_Modes with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Profiles_ModesMultiError,
// or nil if none found.
func (m *Profiles_Modes) ValidateAll() error {
	return m.validate(true)
}

func (m *Profiles_Modes) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEditor()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Profiles_ModesValidationError{
					field:  "Editor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Profiles_ModesValidationError{
					field:  "Editor",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEditor()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Profiles_ModesValidationError{
				field:  "Editor",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPreview()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Profiles_ModesValidationError{
					field:  "Preview",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Profiles_ModesValidationError{
					field:  "Preview",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPreview()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Profiles_ModesValidationError{
				field:  "Preview",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeployed()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Profiles_ModesValidationError{
					field:  "Deployed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Profiles_ModesValidationError{
					field:  "Deployed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeployed()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Profiles_ModesValidationError{
				field:  "Deployed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Profiles_ModesMultiError(errors)
	}

	return nil
}

// Profiles_ModesMultiError is an error wrapping multiple validation errors
// returned by Profiles_Modes.ValidateAll() if the designated constraints
// aren't met.
type Profiles_ModesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Profiles_ModesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Profiles_ModesMultiError) AllErrors() []error { return m }

// Profiles_ModesValidationError is the validation error returned by
// Profiles_Modes.Validate if the designated constraints aren't met.
type Profiles_ModesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Profiles_ModesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Profiles_ModesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Profiles_ModesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Profiles_ModesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Profiles_ModesValidationError) ErrorName() string { return "Profiles_ModesValidationError" }

// Error satisfies the builtin error interface
func (e Profiles_ModesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfiles_Modes.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Profiles_ModesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Profiles_ModesValidationError{}

// Validate checks the field values on Profiles_Modes_Settings with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Profiles_Modes_Settings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Profiles_Modes_Settings with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Profiles_Modes_SettingsMultiError, or nil if none found.
func (m *Profiles_Modes_Settings) ValidateAll() error {
	return m.validate(true)
}

func (m *Profiles_Modes_Settings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Default

	if len(errors) > 0 {
		return Profiles_Modes_SettingsMultiError(errors)
	}

	return nil
}

// Profiles_Modes_SettingsMultiError is an error wrapping multiple validation
// errors returned by Profiles_Modes_Settings.ValidateAll() if the designated
// constraints aren't met.
type Profiles_Modes_SettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Profiles_Modes_SettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Profiles_Modes_SettingsMultiError) AllErrors() []error { return m }

// Profiles_Modes_SettingsValidationError is the validation error returned by
// Profiles_Modes_Settings.Validate if the designated constraints aren't met.
type Profiles_Modes_SettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Profiles_Modes_SettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Profiles_Modes_SettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Profiles_Modes_SettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Profiles_Modes_SettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Profiles_Modes_SettingsValidationError) ErrorName() string {
	return "Profiles_Modes_SettingsValidationError"
}

// Error satisfies the builtin error interface
func (e Profiles_Modes_SettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProfiles_Modes_Settings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Profiles_Modes_SettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Profiles_Modes_SettingsValidationError{}

// Validate checks the field values on Trigger_Application with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Application) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Application with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_ApplicationMultiError, or nil if none found.
func (m *Trigger_Application) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Application) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_ApplicationValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_ApplicationValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_ApplicationValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if m.PageId != nil {
		// no validation rules for PageId
	}

	if len(errors) > 0 {
		return Trigger_ApplicationMultiError(errors)
	}

	return nil
}

// Trigger_ApplicationMultiError is an error wrapping multiple validation
// errors returned by Trigger_Application.ValidateAll() if the designated
// constraints aren't met.
type Trigger_ApplicationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_ApplicationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_ApplicationMultiError) AllErrors() []error { return m }

// Trigger_ApplicationValidationError is the validation error returned by
// Trigger_Application.Validate if the designated constraints aren't met.
type Trigger_ApplicationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_ApplicationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_ApplicationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_ApplicationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_ApplicationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_ApplicationValidationError) ErrorName() string {
	return "Trigger_ApplicationValidationError"
}

// Error satisfies the builtin error interface
func (e Trigger_ApplicationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Application.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_ApplicationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_ApplicationValidationError{}

// Validate checks the field values on Trigger_Workflow with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Workflow) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Workflow with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_WorkflowMultiError, or nil if none found.
func (m *Trigger_Workflow) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Workflow) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_WorkflowValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_WorkflowValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_WorkflowValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParameters()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_WorkflowValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_WorkflowValidationError{
					field:  "Parameters",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParameters()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_WorkflowValidationError{
				field:  "Parameters",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Trigger_WorkflowMultiError(errors)
	}

	return nil
}

// Trigger_WorkflowMultiError is an error wrapping multiple validation errors
// returned by Trigger_Workflow.ValidateAll() if the designated constraints
// aren't met.
type Trigger_WorkflowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_WorkflowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_WorkflowMultiError) AllErrors() []error { return m }

// Trigger_WorkflowValidationError is the validation error returned by
// Trigger_Workflow.Validate if the designated constraints aren't met.
type Trigger_WorkflowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_WorkflowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_WorkflowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_WorkflowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_WorkflowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_WorkflowValidationError) ErrorName() string { return "Trigger_WorkflowValidationError" }

// Error satisfies the builtin error interface
func (e Trigger_WorkflowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Workflow.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_WorkflowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_WorkflowValidationError{}

// Validate checks the field values on Trigger_Job with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Trigger_Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Job with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Trigger_JobMultiError, or
// nil if none found.
func (m *Trigger_Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_JobValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_JobValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_JobValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetFrequency() < 1 {
		err := Trigger_JobValidationError{
			field:  "Frequency",
			reason: "value must be greater than or equal to 1",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Interval

	if val := m.GetDayOfMonth(); val < 1 || val > 32 {
		err := Trigger_JobValidationError{
			field:  "DayOfMonth",
			reason: "value must be inside range [1, 32]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetDays()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_JobValidationError{
					field:  "Days",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_JobValidationError{
					field:  "Days",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDays()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_JobValidationError{
				field:  "Days",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_JobValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_JobValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_JobValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TimezoneLocale

	if len(errors) > 0 {
		return Trigger_JobMultiError(errors)
	}

	return nil
}

// Trigger_JobMultiError is an error wrapping multiple validation errors
// returned by Trigger_Job.ValidateAll() if the designated constraints aren't met.
type Trigger_JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_JobMultiError) AllErrors() []error { return m }

// Trigger_JobValidationError is the validation error returned by
// Trigger_Job.Validate if the designated constraints aren't met.
type Trigger_JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_JobValidationError) ErrorName() string { return "Trigger_JobValidationError" }

// Error satisfies the builtin error interface
func (e Trigger_JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Job.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_JobValidationError{}

// Validate checks the field values on Trigger_Application_Options with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Application_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Application_Options with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_Application_OptionsMultiError, or nil if none found.
func (m *Trigger_Application_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Application_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.ExecuteOnPageLoad != nil {
		// no validation rules for ExecuteOnPageLoad
	}

	if len(errors) > 0 {
		return Trigger_Application_OptionsMultiError(errors)
	}

	return nil
}

// Trigger_Application_OptionsMultiError is an error wrapping multiple
// validation errors returned by Trigger_Application_Options.ValidateAll() if
// the designated constraints aren't met.
type Trigger_Application_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_Application_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_Application_OptionsMultiError) AllErrors() []error { return m }

// Trigger_Application_OptionsValidationError is the validation error returned
// by Trigger_Application_Options.Validate if the designated constraints
// aren't met.
type Trigger_Application_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_Application_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_Application_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_Application_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_Application_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_Application_OptionsValidationError) ErrorName() string {
	return "Trigger_Application_OptionsValidationError"
}

// Error satisfies the builtin error interface
func (e Trigger_Application_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Application_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_Application_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_Application_OptionsValidationError{}

// Validate checks the field values on Trigger_Workflow_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Workflow_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Workflow_Options with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_Workflow_OptionsMultiError, or nil if none found.
func (m *Trigger_Workflow_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Workflow_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfiles()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_Workflow_OptionsValidationError{
					field:  "Profiles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_Workflow_OptionsValidationError{
					field:  "Profiles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfiles()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_Workflow_OptionsValidationError{
				field:  "Profiles",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.DeployedCommitId != nil {
		// no validation rules for DeployedCommitId
	}

	if len(errors) > 0 {
		return Trigger_Workflow_OptionsMultiError(errors)
	}

	return nil
}

// Trigger_Workflow_OptionsMultiError is an error wrapping multiple validation
// errors returned by Trigger_Workflow_Options.ValidateAll() if the designated
// constraints aren't met.
type Trigger_Workflow_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_Workflow_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_Workflow_OptionsMultiError) AllErrors() []error { return m }

// Trigger_Workflow_OptionsValidationError is the validation error returned by
// Trigger_Workflow_Options.Validate if the designated constraints aren't met.
type Trigger_Workflow_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_Workflow_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_Workflow_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_Workflow_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_Workflow_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_Workflow_OptionsValidationError) ErrorName() string {
	return "Trigger_Workflow_OptionsValidationError"
}

// Error satisfies the builtin error interface
func (e Trigger_Workflow_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Workflow_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_Workflow_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_Workflow_OptionsValidationError{}

// Validate checks the field values on Trigger_Workflow_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Workflow_Parameters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Workflow_Parameters with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_Workflow_ParametersMultiError, or nil if none found.
func (m *Trigger_Workflow_Parameters) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Workflow_Parameters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetQuery()))
		i := 0
		for key := range m.GetQuery() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetQuery()[key]
			_ = val

			// no validation rules for Query[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, Trigger_Workflow_ParametersValidationError{
							field:  fmt.Sprintf("Query[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, Trigger_Workflow_ParametersValidationError{
							field:  fmt.Sprintf("Query[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return Trigger_Workflow_ParametersValidationError{
						field:  fmt.Sprintf("Query[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]string, len(m.GetBody()))
		i := 0
		for key := range m.GetBody() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetBody()[key]
			_ = val

			// no validation rules for Body[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, Trigger_Workflow_ParametersValidationError{
							field:  fmt.Sprintf("Body[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, Trigger_Workflow_ParametersValidationError{
							field:  fmt.Sprintf("Body[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return Trigger_Workflow_ParametersValidationError{
						field:  fmt.Sprintf("Body[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return Trigger_Workflow_ParametersMultiError(errors)
	}

	return nil
}

// Trigger_Workflow_ParametersMultiError is an error wrapping multiple
// validation errors returned by Trigger_Workflow_Parameters.ValidateAll() if
// the designated constraints aren't met.
type Trigger_Workflow_ParametersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_Workflow_ParametersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_Workflow_ParametersMultiError) AllErrors() []error { return m }

// Trigger_Workflow_ParametersValidationError is the validation error returned
// by Trigger_Workflow_Parameters.Validate if the designated constraints
// aren't met.
type Trigger_Workflow_ParametersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_Workflow_ParametersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_Workflow_ParametersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_Workflow_ParametersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_Workflow_ParametersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_Workflow_ParametersValidationError) ErrorName() string {
	return "Trigger_Workflow_ParametersValidationError"
}

// Error satisfies the builtin error interface
func (e Trigger_Workflow_ParametersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Workflow_Parameters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_Workflow_ParametersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_Workflow_ParametersValidationError{}

// Validate checks the field values on Trigger_Workflow_Parameters_QueryParam
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Trigger_Workflow_Parameters_QueryParam) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Trigger_Workflow_Parameters_QueryParam with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Trigger_Workflow_Parameters_QueryParamMultiError, or nil if none found.
func (m *Trigger_Workflow_Parameters_QueryParam) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Workflow_Parameters_QueryParam) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Trigger_Workflow_Parameters_QueryParamMultiError(errors)
	}

	return nil
}

// Trigger_Workflow_Parameters_QueryParamMultiError is an error wrapping
// multiple validation errors returned by
// Trigger_Workflow_Parameters_QueryParam.ValidateAll() if the designated
// constraints aren't met.
type Trigger_Workflow_Parameters_QueryParamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_Workflow_Parameters_QueryParamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_Workflow_Parameters_QueryParamMultiError) AllErrors() []error { return m }

// Trigger_Workflow_Parameters_QueryParamValidationError is the validation
// error returned by Trigger_Workflow_Parameters_QueryParam.Validate if the
// designated constraints aren't met.
type Trigger_Workflow_Parameters_QueryParamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_Workflow_Parameters_QueryParamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_Workflow_Parameters_QueryParamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_Workflow_Parameters_QueryParamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_Workflow_Parameters_QueryParamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_Workflow_Parameters_QueryParamValidationError) ErrorName() string {
	return "Trigger_Workflow_Parameters_QueryParamValidationError"
}

// Error satisfies the builtin error interface
func (e Trigger_Workflow_Parameters_QueryParamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Workflow_Parameters_QueryParam.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_Workflow_Parameters_QueryParamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_Workflow_Parameters_QueryParamValidationError{}

// Validate checks the field values on Trigger_Job_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Job_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Job_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_Job_OptionsMultiError, or nil if none found.
func (m *Trigger_Job_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Job_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProfiles()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Trigger_Job_OptionsValidationError{
					field:  "Profiles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Trigger_Job_OptionsValidationError{
					field:  "Profiles",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProfiles()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Trigger_Job_OptionsValidationError{
				field:  "Profiles",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SendEmailOnFailure

	if m.DeployedCommitId != nil {
		// no validation rules for DeployedCommitId
	}

	if len(errors) > 0 {
		return Trigger_Job_OptionsMultiError(errors)
	}

	return nil
}

// Trigger_Job_OptionsMultiError is an error wrapping multiple validation
// errors returned by Trigger_Job_Options.ValidateAll() if the designated
// constraints aren't met.
type Trigger_Job_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_Job_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_Job_OptionsMultiError) AllErrors() []error { return m }

// Trigger_Job_OptionsValidationError is the validation error returned by
// Trigger_Job_Options.Validate if the designated constraints aren't met.
type Trigger_Job_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_Job_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_Job_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_Job_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_Job_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_Job_OptionsValidationError) ErrorName() string {
	return "Trigger_Job_OptionsValidationError"
}

// Error satisfies the builtin error interface
func (e Trigger_Job_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Job_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_Job_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_Job_OptionsValidationError{}

// Validate checks the field values on Trigger_Job_Days with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Trigger_Job_Days) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger_Job_Days with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Trigger_Job_DaysMultiError, or nil if none found.
func (m *Trigger_Job_Days) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger_Job_Days) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Sunday

	// no validation rules for Monday

	// no validation rules for Tuesday

	// no validation rules for Wednesday

	// no validation rules for Thursday

	// no validation rules for Friday

	// no validation rules for Saturday

	if len(errors) > 0 {
		return Trigger_Job_DaysMultiError(errors)
	}

	return nil
}

// Trigger_Job_DaysMultiError is an error wrapping multiple validation errors
// returned by Trigger_Job_Days.ValidateAll() if the designated constraints
// aren't met.
type Trigger_Job_DaysMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Trigger_Job_DaysMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Trigger_Job_DaysMultiError) AllErrors() []error { return m }

// Trigger_Job_DaysValidationError is the validation error returned by
// Trigger_Job_Days.Validate if the designated constraints aren't met.
type Trigger_Job_DaysValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Trigger_Job_DaysValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Trigger_Job_DaysValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Trigger_Job_DaysValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Trigger_Job_DaysValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Trigger_Job_DaysValidationError) ErrorName() string { return "Trigger_Job_DaysValidationError" }

// Error satisfies the builtin error interface
func (e Trigger_Job_DaysValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger_Job_Days.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Trigger_Job_DaysValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Trigger_Job_DaysValidationError{}

// Validate checks the field values on Block_Parallel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Parallel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Parallel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_ParallelMultiError,
// or nil if none found.
func (m *Block_Parallel) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Parallel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _Block_Parallel_Wait_NotInLookup[m.GetWait()]; ok {
		err := Block_ParallelValidationError{
			field:  "Wait",
			reason: "value must not be in list [WAIT_UNSPECIFIED]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	oneofConfigPresent := false
	switch v := m.Config.(type) {
	case *Block_Parallel_Static_:
		if v == nil {
			err := Block_ParallelValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetStatic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Block_ParallelValidationError{
						field:  "Static",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Block_ParallelValidationError{
						field:  "Static",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStatic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Block_ParallelValidationError{
					field:  "Static",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Block_Parallel_Dynamic_:
		if v == nil {
			err := Block_ParallelValidationError{
				field:  "Config",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofConfigPresent = true

		if all {
			switch v := interface{}(m.GetDynamic()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Block_ParallelValidationError{
						field:  "Dynamic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Block_ParallelValidationError{
						field:  "Dynamic",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamic()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Block_ParallelValidationError{
					field:  "Dynamic",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	if !oneofConfigPresent {
		err := Block_ParallelValidationError{
			field:  "Config",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.PoolSize != nil {
		// no validation rules for PoolSize
	}

	if len(errors) > 0 {
		return Block_ParallelMultiError(errors)
	}

	return nil
}

// Block_ParallelMultiError is an error wrapping multiple validation errors
// returned by Block_Parallel.ValidateAll() if the designated constraints
// aren't met.
type Block_ParallelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_ParallelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_ParallelMultiError) AllErrors() []error { return m }

// Block_ParallelValidationError is the validation error returned by
// Block_Parallel.Validate if the designated constraints aren't met.
type Block_ParallelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_ParallelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_ParallelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_ParallelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_ParallelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_ParallelValidationError) ErrorName() string { return "Block_ParallelValidationError" }

// Error satisfies the builtin error interface
func (e Block_ParallelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Parallel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_ParallelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_ParallelValidationError{}

var _Block_Parallel_Wait_NotInLookup = map[Block_Parallel_Wait]struct{}{
	0: {},
}

// Validate checks the field values on Block_Conditional with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Block_Conditional) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Conditional with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_ConditionalMultiError, or nil if none found.
func (m *Block_Conditional) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Conditional) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIf()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_ConditionalValidationError{
					field:  "If",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_ConditionalValidationError{
					field:  "If",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIf()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_ConditionalValidationError{
				field:  "If",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetElseIf() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Block_ConditionalValidationError{
						field:  fmt.Sprintf("ElseIf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Block_ConditionalValidationError{
						field:  fmt.Sprintf("ElseIf[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Block_ConditionalValidationError{
					field:  fmt.Sprintf("ElseIf[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetElse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_ConditionalValidationError{
					field:  "Else",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_ConditionalValidationError{
					field:  "Else",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetElse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_ConditionalValidationError{
				field:  "Else",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Block_ConditionalMultiError(errors)
	}

	return nil
}

// Block_ConditionalMultiError is an error wrapping multiple validation errors
// returned by Block_Conditional.ValidateAll() if the designated constraints
// aren't met.
type Block_ConditionalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_ConditionalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_ConditionalMultiError) AllErrors() []error { return m }

// Block_ConditionalValidationError is the validation error returned by
// Block_Conditional.Validate if the designated constraints aren't met.
type Block_ConditionalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_ConditionalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_ConditionalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_ConditionalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_ConditionalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_ConditionalValidationError) ErrorName() string {
	return "Block_ConditionalValidationError"
}

// Error satisfies the builtin error interface
func (e Block_ConditionalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Conditional.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_ConditionalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_ConditionalValidationError{}

// Validate checks the field values on Block_Loop with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Loop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Loop with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_LoopMultiError, or
// nil if none found.
func (m *Block_Loop) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Loop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetRange(), "{{") {
		err := Block_LoopValidationError{
			field:  "Range",
			reason: "value does not have prefix \"{{\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasSuffix(m.GetRange(), "}}") {
		err := Block_LoopValidationError{
			field:  "Range",
			reason: "value does not have suffix \"}}\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetVariables()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_LoopValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_LoopValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVariables()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_LoopValidationError{
				field:  "Variables",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Block_LoopValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Block_LoopValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Block_LoopValidationError{
					field:  fmt.Sprintf("Blocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Block_LoopMultiError(errors)
	}

	return nil
}

// Block_LoopMultiError is an error wrapping multiple validation errors
// returned by Block_Loop.ValidateAll() if the designated constraints aren't met.
type Block_LoopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_LoopMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_LoopMultiError) AllErrors() []error { return m }

// Block_LoopValidationError is the validation error returned by
// Block_Loop.Validate if the designated constraints aren't met.
type Block_LoopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_LoopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_LoopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_LoopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_LoopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_LoopValidationError) ErrorName() string { return "Block_LoopValidationError" }

// Error satisfies the builtin error interface
func (e Block_LoopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Loop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_LoopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_LoopValidationError{}

// Validate checks the field values on Block_TryCatch with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_TryCatch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_TryCatch with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_TryCatchMultiError,
// or nil if none found.
func (m *Block_TryCatch) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_TryCatch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTry()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Try",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Try",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTry()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_TryCatchValidationError{
				field:  "Try",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Catch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Catch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_TryCatchValidationError{
				field:  "Catch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinally()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Finally",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Finally",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinally()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_TryCatchValidationError{
				field:  "Finally",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetVariables()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_TryCatchValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVariables()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_TryCatchValidationError{
				field:  "Variables",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Block_TryCatchMultiError(errors)
	}

	return nil
}

// Block_TryCatchMultiError is an error wrapping multiple validation errors
// returned by Block_TryCatch.ValidateAll() if the designated constraints
// aren't met.
type Block_TryCatchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_TryCatchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_TryCatchMultiError) AllErrors() []error { return m }

// Block_TryCatchValidationError is the validation error returned by
// Block_TryCatch.Validate if the designated constraints aren't met.
type Block_TryCatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_TryCatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_TryCatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_TryCatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_TryCatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_TryCatchValidationError) ErrorName() string { return "Block_TryCatchValidationError" }

// Error satisfies the builtin error interface
func (e Block_TryCatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_TryCatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_TryCatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_TryCatchValidationError{}

// Validate checks the field values on Block_Break with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Break) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Break with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_BreakMultiError, or
// nil if none found.
func (m *Block_Break) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Break) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetCondition(), "{{") {
		err := Block_BreakValidationError{
			field:  "Condition",
			reason: "value does not have prefix \"{{\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasSuffix(m.GetCondition(), "}}") {
		err := Block_BreakValidationError{
			field:  "Condition",
			reason: "value does not have suffix \"}}\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_BreakMultiError(errors)
	}

	return nil
}

// Block_BreakMultiError is an error wrapping multiple validation errors
// returned by Block_Break.ValidateAll() if the designated constraints aren't met.
type Block_BreakMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_BreakMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_BreakMultiError) AllErrors() []error { return m }

// Block_BreakValidationError is the validation error returned by
// Block_Break.Validate if the designated constraints aren't met.
type Block_BreakValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_BreakValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_BreakValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_BreakValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_BreakValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_BreakValidationError) ErrorName() string { return "Block_BreakValidationError" }

// Error satisfies the builtin error interface
func (e Block_BreakValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Break.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_BreakValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_BreakValidationError{}

// Validate checks the field values on Block_Return with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Return) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Return with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_ReturnMultiError, or
// nil if none found.
func (m *Block_Return) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Return) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetData(), "{{") {
		err := Block_ReturnValidationError{
			field:  "Data",
			reason: "value does not have prefix \"{{\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasSuffix(m.GetData(), "}}") {
		err := Block_ReturnValidationError{
			field:  "Data",
			reason: "value does not have suffix \"}}\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_ReturnMultiError(errors)
	}

	return nil
}

// Block_ReturnMultiError is an error wrapping multiple validation errors
// returned by Block_Return.ValidateAll() if the designated constraints aren't met.
type Block_ReturnMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_ReturnMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_ReturnMultiError) AllErrors() []error { return m }

// Block_ReturnValidationError is the validation error returned by
// Block_Return.Validate if the designated constraints aren't met.
type Block_ReturnValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_ReturnValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_ReturnValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_ReturnValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_ReturnValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_ReturnValidationError) ErrorName() string { return "Block_ReturnValidationError" }

// Error satisfies the builtin error interface
func (e Block_ReturnValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Return.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_ReturnValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_ReturnValidationError{}

// Validate checks the field values on Block_Throw with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Throw) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Throw with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_ThrowMultiError, or
// nil if none found.
func (m *Block_Throw) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Throw) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetError(), "{{") {
		err := Block_ThrowValidationError{
			field:  "Error",
			reason: "value does not have prefix \"{{\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasSuffix(m.GetError(), "}}") {
		err := Block_ThrowValidationError{
			field:  "Error",
			reason: "value does not have suffix \"}}\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_ThrowMultiError(errors)
	}

	return nil
}

// Block_ThrowMultiError is an error wrapping multiple validation errors
// returned by Block_Throw.ValidateAll() if the designated constraints aren't met.
type Block_ThrowMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_ThrowMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_ThrowMultiError) AllErrors() []error { return m }

// Block_ThrowValidationError is the validation error returned by
// Block_Throw.Validate if the designated constraints aren't met.
type Block_ThrowValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_ThrowValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_ThrowValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_ThrowValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_ThrowValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_ThrowValidationError) ErrorName() string { return "Block_ThrowValidationError" }

// Error satisfies the builtin error interface
func (e Block_ThrowValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Throw.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_ThrowValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_ThrowValidationError{}

// Validate checks the field values on Block_Wait with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Wait) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Wait with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_WaitMultiError, or
// nil if none found.
func (m *Block_Wait) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Wait) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetCondition(), "{{") {
		err := Block_WaitValidationError{
			field:  "Condition",
			reason: "value does not have prefix \"{{\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasSuffix(m.GetCondition(), "}}") {
		err := Block_WaitValidationError{
			field:  "Condition",
			reason: "value does not have suffix \"}}\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_WaitMultiError(errors)
	}

	return nil
}

// Block_WaitMultiError is an error wrapping multiple validation errors
// returned by Block_Wait.ValidateAll() if the designated constraints aren't met.
type Block_WaitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_WaitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_WaitMultiError) AllErrors() []error { return m }

// Block_WaitValidationError is the validation error returned by
// Block_Wait.Validate if the designated constraints aren't met.
type Block_WaitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_WaitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_WaitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_WaitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_WaitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_WaitValidationError) ErrorName() string { return "Block_WaitValidationError" }

// Error satisfies the builtin error interface
func (e Block_WaitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Wait.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_WaitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_WaitValidationError{}

// Validate checks the field values on Block_Stream with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Stream) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Stream with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_StreamMultiError, or
// nil if none found.
func (m *Block_Stream) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Stream) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetTrigger() == nil {
		err := Block_StreamValidationError{
			field:  "Trigger",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetTrigger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrigger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_StreamValidationError{
				field:  "Trigger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProcess()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Process",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Process",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProcess()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_StreamValidationError{
				field:  "Process",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetVariables() == nil {
		err := Block_StreamValidationError{
			field:  "Variables",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetVariables()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVariables()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_StreamValidationError{
				field:  "Variables",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOptions()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_StreamValidationError{
					field:  "Options",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOptions()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_StreamValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Block_StreamMultiError(errors)
	}

	return nil
}

// Block_StreamMultiError is an error wrapping multiple validation errors
// returned by Block_Stream.ValidateAll() if the designated constraints aren't met.
type Block_StreamMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_StreamMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_StreamMultiError) AllErrors() []error { return m }

// Block_StreamValidationError is the validation error returned by
// Block_Stream.Validate if the designated constraints aren't met.
type Block_StreamValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_StreamValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_StreamValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_StreamValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_StreamValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_StreamValidationError) ErrorName() string { return "Block_StreamValidationError" }

// Error satisfies the builtin error interface
func (e Block_StreamValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Stream.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_StreamValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_StreamValidationError{}

// Validate checks the field values on Block_Send with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Block_Send) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Send with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Block_SendMultiError, or
// nil if none found.
func (m *Block_Send) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Send) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetMessage()) < 1 {
		err := Block_SendValidationError{
			field:  "Message",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_SendMultiError(errors)
	}

	return nil
}

// Block_SendMultiError is an error wrapping multiple validation errors
// returned by Block_Send.ValidateAll() if the designated constraints aren't met.
type Block_SendMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_SendMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_SendMultiError) AllErrors() []error { return m }

// Block_SendValidationError is the validation error returned by
// Block_Send.Validate if the designated constraints aren't met.
type Block_SendValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_SendValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_SendValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_SendValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_SendValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_SendValidationError) ErrorName() string { return "Block_SendValidationError" }

// Error satisfies the builtin error interface
func (e Block_SendValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Send.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_SendValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_SendValidationError{}

// Validate checks the field values on Block_Parallel_Static with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Parallel_Static) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Parallel_Static with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Parallel_StaticMultiError, or nil if none found.
func (m *Block_Parallel_Static) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Parallel_Static) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetPaths()))
		i := 0
		for key := range m.GetPaths() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetPaths()[key]
			_ = val

			// no validation rules for Paths[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, Block_Parallel_StaticValidationError{
							field:  fmt.Sprintf("Paths[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, Block_Parallel_StaticValidationError{
							field:  fmt.Sprintf("Paths[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return Block_Parallel_StaticValidationError{
						field:  fmt.Sprintf("Paths[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return Block_Parallel_StaticMultiError(errors)
	}

	return nil
}

// Block_Parallel_StaticMultiError is an error wrapping multiple validation
// errors returned by Block_Parallel_Static.ValidateAll() if the designated
// constraints aren't met.
type Block_Parallel_StaticMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Parallel_StaticMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Parallel_StaticMultiError) AllErrors() []error { return m }

// Block_Parallel_StaticValidationError is the validation error returned by
// Block_Parallel_Static.Validate if the designated constraints aren't met.
type Block_Parallel_StaticValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Parallel_StaticValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Parallel_StaticValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Parallel_StaticValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Parallel_StaticValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Parallel_StaticValidationError) ErrorName() string {
	return "Block_Parallel_StaticValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Parallel_StaticValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Parallel_Static.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Parallel_StaticValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Parallel_StaticValidationError{}

// Validate checks the field values on Block_Parallel_Dynamic with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Parallel_Dynamic) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Parallel_Dynamic with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Parallel_DynamicMultiError, or nil if none found.
func (m *Block_Parallel_Dynamic) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Parallel_Dynamic) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Paths

	if all {
		switch v := interface{}(m.GetVariables()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_Parallel_DynamicValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_Parallel_DynamicValidationError{
					field:  "Variables",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVariables()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_Parallel_DynamicValidationError{
				field:  "Variables",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Block_Parallel_DynamicValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Block_Parallel_DynamicValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Block_Parallel_DynamicValidationError{
					field:  fmt.Sprintf("Blocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Block_Parallel_DynamicMultiError(errors)
	}

	return nil
}

// Block_Parallel_DynamicMultiError is an error wrapping multiple validation
// errors returned by Block_Parallel_Dynamic.ValidateAll() if the designated
// constraints aren't met.
type Block_Parallel_DynamicMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Parallel_DynamicMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Parallel_DynamicMultiError) AllErrors() []error { return m }

// Block_Parallel_DynamicValidationError is the validation error returned by
// Block_Parallel_Dynamic.Validate if the designated constraints aren't met.
type Block_Parallel_DynamicValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Parallel_DynamicValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Parallel_DynamicValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Parallel_DynamicValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Parallel_DynamicValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Parallel_DynamicValidationError) ErrorName() string {
	return "Block_Parallel_DynamicValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Parallel_DynamicValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Parallel_Dynamic.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Parallel_DynamicValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Parallel_DynamicValidationError{}

// Validate checks the field values on Block_Parallel_Dynamic_Variables with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Block_Parallel_Dynamic_Variables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Parallel_Dynamic_Variables with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Block_Parallel_Dynamic_VariablesMultiError, or nil if none found.
func (m *Block_Parallel_Dynamic_Variables) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Parallel_Dynamic_Variables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetItem()) < 1 {
		err := Block_Parallel_Dynamic_VariablesValidationError{
			field:  "Item",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_Parallel_Dynamic_VariablesMultiError(errors)
	}

	return nil
}

// Block_Parallel_Dynamic_VariablesMultiError is an error wrapping multiple
// validation errors returned by
// Block_Parallel_Dynamic_Variables.ValidateAll() if the designated
// constraints aren't met.
type Block_Parallel_Dynamic_VariablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Parallel_Dynamic_VariablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Parallel_Dynamic_VariablesMultiError) AllErrors() []error { return m }

// Block_Parallel_Dynamic_VariablesValidationError is the validation error
// returned by Block_Parallel_Dynamic_Variables.Validate if the designated
// constraints aren't met.
type Block_Parallel_Dynamic_VariablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Parallel_Dynamic_VariablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Parallel_Dynamic_VariablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Parallel_Dynamic_VariablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Parallel_Dynamic_VariablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Parallel_Dynamic_VariablesValidationError) ErrorName() string {
	return "Block_Parallel_Dynamic_VariablesValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Parallel_Dynamic_VariablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Parallel_Dynamic_Variables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Parallel_Dynamic_VariablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Parallel_Dynamic_VariablesValidationError{}

// Validate checks the field values on Block_Conditional_Condition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Conditional_Condition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Conditional_Condition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Conditional_ConditionMultiError, or nil if none found.
func (m *Block_Conditional_Condition) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Conditional_Condition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !strings.HasPrefix(m.GetCondition(), "{{") {
		err := Block_Conditional_ConditionValidationError{
			field:  "Condition",
			reason: "value does not have prefix \"{{\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !strings.HasSuffix(m.GetCondition(), "}}") {
		err := Block_Conditional_ConditionValidationError{
			field:  "Condition",
			reason: "value does not have suffix \"}}\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetBlocks() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Block_Conditional_ConditionValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Block_Conditional_ConditionValidationError{
						field:  fmt.Sprintf("Blocks[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Block_Conditional_ConditionValidationError{
					field:  fmt.Sprintf("Blocks[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Block_Conditional_ConditionMultiError(errors)
	}

	return nil
}

// Block_Conditional_ConditionMultiError is an error wrapping multiple
// validation errors returned by Block_Conditional_Condition.ValidateAll() if
// the designated constraints aren't met.
type Block_Conditional_ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Conditional_ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Conditional_ConditionMultiError) AllErrors() []error { return m }

// Block_Conditional_ConditionValidationError is the validation error returned
// by Block_Conditional_Condition.Validate if the designated constraints
// aren't met.
type Block_Conditional_ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Conditional_ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Conditional_ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Conditional_ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Conditional_ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Conditional_ConditionValidationError) ErrorName() string {
	return "Block_Conditional_ConditionValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Conditional_ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Conditional_Condition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Conditional_ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Conditional_ConditionValidationError{}

// Validate checks the field values on Block_Loop_Variables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Loop_Variables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Loop_Variables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Loop_VariablesMultiError, or nil if none found.
func (m *Block_Loop_Variables) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Loop_Variables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetIndex()) < 1 {
		err := Block_Loop_VariablesValidationError{
			field:  "Index",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetItem()) < 1 {
		err := Block_Loop_VariablesValidationError{
			field:  "Item",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_Loop_VariablesMultiError(errors)
	}

	return nil
}

// Block_Loop_VariablesMultiError is an error wrapping multiple validation
// errors returned by Block_Loop_Variables.ValidateAll() if the designated
// constraints aren't met.
type Block_Loop_VariablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Loop_VariablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Loop_VariablesMultiError) AllErrors() []error { return m }

// Block_Loop_VariablesValidationError is the validation error returned by
// Block_Loop_Variables.Validate if the designated constraints aren't met.
type Block_Loop_VariablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Loop_VariablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Loop_VariablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Loop_VariablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Loop_VariablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Loop_VariablesValidationError) ErrorName() string {
	return "Block_Loop_VariablesValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Loop_VariablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Loop_Variables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Loop_VariablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Loop_VariablesValidationError{}

// Validate checks the field values on Block_TryCatch_Variables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_TryCatch_Variables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_TryCatch_Variables with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_TryCatch_VariablesMultiError, or nil if none found.
func (m *Block_TryCatch_Variables) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_TryCatch_Variables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetError()) < 1 {
		err := Block_TryCatch_VariablesValidationError{
			field:  "Error",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_TryCatch_VariablesMultiError(errors)
	}

	return nil
}

// Block_TryCatch_VariablesMultiError is an error wrapping multiple validation
// errors returned by Block_TryCatch_Variables.ValidateAll() if the designated
// constraints aren't met.
type Block_TryCatch_VariablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_TryCatch_VariablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_TryCatch_VariablesMultiError) AllErrors() []error { return m }

// Block_TryCatch_VariablesValidationError is the validation error returned by
// Block_TryCatch_Variables.Validate if the designated constraints aren't met.
type Block_TryCatch_VariablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_TryCatch_VariablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_TryCatch_VariablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_TryCatch_VariablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_TryCatch_VariablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_TryCatch_VariablesValidationError) ErrorName() string {
	return "Block_TryCatch_VariablesValidationError"
}

// Error satisfies the builtin error interface
func (e Block_TryCatch_VariablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_TryCatch_Variables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_TryCatch_VariablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_TryCatch_VariablesValidationError{}

// Validate checks the field values on Block_Stream_Variables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Stream_Variables) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Stream_Variables with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Stream_VariablesMultiError, or nil if none found.
func (m *Block_Stream_Variables) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Stream_Variables) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetItem()) < 1 {
		err := Block_Stream_VariablesValidationError{
			field:  "Item",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Block_Stream_VariablesMultiError(errors)
	}

	return nil
}

// Block_Stream_VariablesMultiError is an error wrapping multiple validation
// errors returned by Block_Stream_Variables.ValidateAll() if the designated
// constraints aren't met.
type Block_Stream_VariablesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Stream_VariablesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Stream_VariablesMultiError) AllErrors() []error { return m }

// Block_Stream_VariablesValidationError is the validation error returned by
// Block_Stream_Variables.Validate if the designated constraints aren't met.
type Block_Stream_VariablesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Stream_VariablesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Stream_VariablesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Stream_VariablesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Stream_VariablesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Stream_VariablesValidationError) ErrorName() string {
	return "Block_Stream_VariablesValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Stream_VariablesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Stream_Variables.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Stream_VariablesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Stream_VariablesValidationError{}

// Validate checks the field values on Block_Stream_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Stream_Options) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Stream_Options with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Stream_OptionsMultiError, or nil if none found.
func (m *Block_Stream_Options) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Stream_Options) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DisableAutoSend

	if len(errors) > 0 {
		return Block_Stream_OptionsMultiError(errors)
	}

	return nil
}

// Block_Stream_OptionsMultiError is an error wrapping multiple validation
// errors returned by Block_Stream_Options.ValidateAll() if the designated
// constraints aren't met.
type Block_Stream_OptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Stream_OptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Stream_OptionsMultiError) AllErrors() []error { return m }

// Block_Stream_OptionsValidationError is the validation error returned by
// Block_Stream_Options.Validate if the designated constraints aren't met.
type Block_Stream_OptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Stream_OptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Stream_OptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Stream_OptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Stream_OptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Stream_OptionsValidationError) ErrorName() string {
	return "Block_Stream_OptionsValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Stream_OptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Stream_Options.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Stream_OptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Stream_OptionsValidationError{}

// Validate checks the field values on Block_Stream_Trigger with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Block_Stream_Trigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Block_Stream_Trigger with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Block_Stream_TriggerMultiError, or nil if none found.
func (m *Block_Stream_Trigger) ValidateAll() error {
	return m.validate(true)
}

func (m *Block_Stream_Trigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetName()) < 1 {
		err := Block_Stream_TriggerValidationError{
			field:  "Name",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStep()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Block_Stream_TriggerValidationError{
					field:  "Step",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Block_Stream_TriggerValidationError{
					field:  "Step",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStep()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Block_Stream_TriggerValidationError{
				field:  "Step",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Block_Stream_TriggerMultiError(errors)
	}

	return nil
}

// Block_Stream_TriggerMultiError is an error wrapping multiple validation
// errors returned by Block_Stream_Trigger.ValidateAll() if the designated
// constraints aren't met.
type Block_Stream_TriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Block_Stream_TriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Block_Stream_TriggerMultiError) AllErrors() []error { return m }

// Block_Stream_TriggerValidationError is the validation error returned by
// Block_Stream_Trigger.Validate if the designated constraints aren't met.
type Block_Stream_TriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Block_Stream_TriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Block_Stream_TriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Block_Stream_TriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Block_Stream_TriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Block_Stream_TriggerValidationError) ErrorName() string {
	return "Block_Stream_TriggerValidationError"
}

// Error satisfies the builtin error interface
func (e Block_Stream_TriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBlock_Stream_Trigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Block_Stream_TriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Block_Stream_TriggerValidationError{}
