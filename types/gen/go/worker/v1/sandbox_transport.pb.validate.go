// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: worker/v1/sandbox_transport.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on RequestMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestMetadataMultiError, or nil if none found.
func (m *RequestMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PluginName

	if len(errors) > 0 {
		return RequestMetadataMultiError(errors)
	}

	return nil
}

// RequestMetadataMultiError is an error wrapping multiple validation errors
// returned by RequestMetadata.ValidateAll() if the designated constraints
// aren't met.
type RequestMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestMetadataMultiError) AllErrors() []error { return m }

// RequestMetadataValidationError is the validation error returned by
// RequestMetadata.Validate if the designated constraints aren't met.
type RequestMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestMetadataValidationError) ErrorName() string { return "RequestMetadataValidationError" }

// Error satisfies the builtin error interface
func (e RequestMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestMetadataValidationError{}

// Validate checks the field values on ExecuteRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ExecuteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ExecuteRequestMultiError,
// or nil if none found.
func (m *ExecuteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProps()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Props",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Props",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProps()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Props",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQuotas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Quotas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Quotas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuotas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Quotas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPinned()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteRequestValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPinned()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteRequestValidationError{
				field:  "Pinned",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VariableStoreAddress

	if len(errors) > 0 {
		return ExecuteRequestMultiError(errors)
	}

	return nil
}

// ExecuteRequestMultiError is an error wrapping multiple validation errors
// returned by ExecuteRequest.ValidateAll() if the designated constraints
// aren't met.
type ExecuteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteRequestMultiError) AllErrors() []error { return m }

// ExecuteRequestValidationError is the validation error returned by
// ExecuteRequest.Validate if the designated constraints aren't met.
type ExecuteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteRequestValidationError) ErrorName() string { return "ExecuteRequestValidationError" }

// Error satisfies the builtin error interface
func (e ExecuteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteRequestValidationError{}

// Validate checks the field values on ExecuteResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ExecuteResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ExecuteResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ExecuteResponseMultiError, or nil if none found.
func (m *ExecuteResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ExecuteResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOutput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "Output",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetError()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "Error",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AuthError

	if all {
		switch v := interface{}(m.GetExecutionTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ExecuteResponseValidationError{
					field:  "ExecutionTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutionTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ExecuteResponseValidationError{
				field:  "ExecutionTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetStructuredLog() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponseValidationError{
						field:  fmt.Sprintf("StructuredLog[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponseValidationError{
						field:  fmt.Sprintf("StructuredLog[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponseValidationError{
					field:  fmt.Sprintf("StructuredLog[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.StartTime != nil {

		if all {
			switch v := interface{}(m.GetStartTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ExecuteResponseValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ExecuteResponseValidationError{
						field:  "StartTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ExecuteResponseValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ExecuteResponseMultiError(errors)
	}

	return nil
}

// ExecuteResponseMultiError is an error wrapping multiple validation errors
// returned by ExecuteResponse.ValidateAll() if the designated constraints
// aren't met.
type ExecuteResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExecuteResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExecuteResponseMultiError) AllErrors() []error { return m }

// ExecuteResponseValidationError is the validation error returned by
// ExecuteResponse.Validate if the designated constraints aren't met.
type ExecuteResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExecuteResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExecuteResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExecuteResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExecuteResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExecuteResponseValidationError) ErrorName() string { return "ExecuteResponseValidationError" }

// Error satisfies the builtin error interface
func (e ExecuteResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExecuteResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExecuteResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExecuteResponseValidationError{}

// Validate checks the field values on StreamRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamRequestMultiError, or
// nil if none found.
func (m *StreamRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StreamRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StreamRequestValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StreamRequestValidationError{
				field:  "Request",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StreamRequestMultiError(errors)
	}

	return nil
}

// StreamRequestMultiError is an error wrapping multiple validation errors
// returned by StreamRequest.ValidateAll() if the designated constraints
// aren't met.
type StreamRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamRequestMultiError) AllErrors() []error { return m }

// StreamRequestValidationError is the validation error returned by
// StreamRequest.Validate if the designated constraints aren't met.
type StreamRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamRequestValidationError) ErrorName() string { return "StreamRequestValidationError" }

// Error satisfies the builtin error interface
func (e StreamRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamRequestValidationError{}

// Validate checks the field values on StreamResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StreamResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StreamResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StreamResponseMultiError,
// or nil if none found.
func (m *StreamResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *StreamResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StreamResponseValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StreamResponseValidationError{
				field:  "Response",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StreamResponseMultiError(errors)
	}

	return nil
}

// StreamResponseMultiError is an error wrapping multiple validation errors
// returned by StreamResponse.ValidateAll() if the designated constraints
// aren't met.
type StreamResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StreamResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StreamResponseMultiError) AllErrors() []error { return m }

// StreamResponseValidationError is the validation error returned by
// StreamResponse.Validate if the designated constraints aren't met.
type StreamResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StreamResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StreamResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StreamResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StreamResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StreamResponseValidationError) ErrorName() string { return "StreamResponseValidationError" }

// Error satisfies the builtin error interface
func (e StreamResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStreamResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StreamResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StreamResponseValidationError{}

// Validate checks the field values on MetadataRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MetadataRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MetadataRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MetadataRequestMultiError, or nil if none found.
func (m *MetadataRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *MetadataRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatasourceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatasourceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataRequestValidationError{
				field:  "DatasourceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "ActionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, MetadataRequestValidationError{
					field:  "ActionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return MetadataRequestValidationError{
				field:  "ActionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VariableStoreAddress

	if len(errors) > 0 {
		return MetadataRequestMultiError(errors)
	}

	return nil
}

// MetadataRequestMultiError is an error wrapping multiple validation errors
// returned by MetadataRequest.ValidateAll() if the designated constraints
// aren't met.
type MetadataRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataRequestMultiError) AllErrors() []error { return m }

// MetadataRequestValidationError is the validation error returned by
// MetadataRequest.Validate if the designated constraints aren't met.
type MetadataRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataRequestValidationError) ErrorName() string { return "MetadataRequestValidationError" }

// Error satisfies the builtin error interface
func (e MetadataRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadataRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataRequestValidationError{}

// Validate checks the field values on TestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TestRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TestRequestMultiError, or
// nil if none found.
func (m *TestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatasourceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatasourceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRequestValidationError{
				field:  "DatasourceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActionConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "ActionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TestRequestValidationError{
					field:  "ActionConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TestRequestValidationError{
				field:  "ActionConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VariableStoreAddress

	if len(errors) > 0 {
		return TestRequestMultiError(errors)
	}

	return nil
}

// TestRequestMultiError is an error wrapping multiple validation errors
// returned by TestRequest.ValidateAll() if the designated constraints aren't met.
type TestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TestRequestMultiError) AllErrors() []error { return m }

// TestRequestValidationError is the validation error returned by
// TestRequest.Validate if the designated constraints aren't met.
type TestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TestRequestValidationError) ErrorName() string { return "TestRequestValidationError" }

// Error satisfies the builtin error interface
func (e TestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TestRequestValidationError{}

// Validate checks the field values on PreDeleteRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PreDeleteRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PreDeleteRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PreDeleteRequestMultiError, or nil if none found.
func (m *PreDeleteRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PreDeleteRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreDeleteRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreDeleteRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreDeleteRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatasourceConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PreDeleteRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PreDeleteRequestValidationError{
					field:  "DatasourceConfig",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatasourceConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PreDeleteRequestValidationError{
				field:  "DatasourceConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PreDeleteRequestMultiError(errors)
	}

	return nil
}

// PreDeleteRequestMultiError is an error wrapping multiple validation errors
// returned by PreDeleteRequest.ValidateAll() if the designated constraints
// aren't met.
type PreDeleteRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PreDeleteRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PreDeleteRequestMultiError) AllErrors() []error { return m }

// PreDeleteRequestValidationError is the validation error returned by
// PreDeleteRequest.Validate if the designated constraints aren't met.
type PreDeleteRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PreDeleteRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PreDeleteRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PreDeleteRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PreDeleteRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PreDeleteRequestValidationError) ErrorName() string { return "PreDeleteRequestValidationError" }

// Error satisfies the builtin error interface
func (e PreDeleteRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPreDeleteRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PreDeleteRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PreDeleteRequestValidationError{}

// Validate checks the field values on StructuredLog with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StructuredLog) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StructuredLog with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StructuredLogMultiError, or
// nil if none found.
func (m *StructuredLog) ValidateAll() error {
	return m.validate(true)
}

func (m *StructuredLog) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Level

	if len(errors) > 0 {
		return StructuredLogMultiError(errors)
	}

	return nil
}

// StructuredLogMultiError is an error wrapping multiple validation errors
// returned by StructuredLog.ValidateAll() if the designated constraints
// aren't met.
type StructuredLogMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StructuredLogMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StructuredLogMultiError) AllErrors() []error { return m }

// StructuredLogValidationError is the validation error returned by
// StructuredLog.Validate if the designated constraints aren't met.
type StructuredLogValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StructuredLogValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StructuredLogValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StructuredLogValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StructuredLogValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StructuredLogValidationError) ErrorName() string { return "StructuredLogValidationError" }

// Error satisfies the builtin error interface
func (e StructuredLogValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStructuredLog.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StructuredLogValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StructuredLogValidationError{}
