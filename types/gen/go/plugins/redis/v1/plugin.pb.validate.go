// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: plugins/redis/v1/plugin.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Plugin with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PluginMultiError, or nil if none found.
func (m *Plugin) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetConnection()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PluginValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PluginValidationError{
					field:  "Connection",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConnection()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PluginValidationError{
				field:  "Connection",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.CommandType.(type) {
	case *Plugin_Raw_:
		if v == nil {
			err := PluginValidationError{
				field:  "CommandType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRaw()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PluginValidationError{
						field:  "Raw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PluginValidationError{
						field:  "Raw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRaw()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PluginValidationError{
					field:  "Raw",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_:
		if v == nil {
			err := PluginValidationError{
				field:  "CommandType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStructured()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PluginValidationError{
						field:  "Structured",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PluginValidationError{
						field:  "Structured",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStructured()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PluginValidationError{
					field:  "Structured",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.DynamicWorkflowConfiguration != nil {

		if all {
			switch v := interface{}(m.GetDynamicWorkflowConfiguration()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PluginValidationError{
						field:  "DynamicWorkflowConfiguration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PluginValidationError{
						field:  "DynamicWorkflowConfiguration",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamicWorkflowConfiguration()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PluginValidationError{
					field:  "DynamicWorkflowConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PluginMultiError(errors)
	}

	return nil
}

// PluginMultiError is an error wrapping multiple validation errors returned by
// Plugin.ValidateAll() if the designated constraints aren't met.
type PluginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PluginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PluginMultiError) AllErrors() []error { return m }

// PluginValidationError is the validation error returned by Plugin.Validate if
// the designated constraints aren't met.
type PluginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PluginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PluginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PluginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PluginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PluginValidationError) ErrorName() string { return "PluginValidationError" }

// Error satisfies the builtin error interface
func (e PluginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PluginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PluginValidationError{}

// Validate checks the field values on Plugin_Raw with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Raw) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Raw with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_RawMultiError, or
// nil if none found.
func (m *Plugin_Raw) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Raw) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Action.(type) {
	case *Plugin_Raw_Singleton_:
		if v == nil {
			err := Plugin_RawValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSingleton()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_RawValidationError{
						field:  "Singleton",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_RawValidationError{
						field:  "Singleton",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSingleton()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_RawValidationError{
					field:  "Singleton",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return Plugin_RawMultiError(errors)
	}

	return nil
}

// Plugin_RawMultiError is an error wrapping multiple validation errors
// returned by Plugin_Raw.ValidateAll() if the designated constraints aren't met.
type Plugin_RawMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_RawMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_RawMultiError) AllErrors() []error { return m }

// Plugin_RawValidationError is the validation error returned by
// Plugin_Raw.Validate if the designated constraints aren't met.
type Plugin_RawValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_RawValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_RawValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_RawValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_RawValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_RawValidationError) ErrorName() string { return "Plugin_RawValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_RawValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Raw.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_RawValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_RawValidationError{}

// Validate checks the field values on Plugin_Structured with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Structured) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Structured with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_StructuredMultiError, or nil if none found.
func (m *Plugin_Structured) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Structured) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Action.(type) {
	case *Plugin_Structured_Get:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Get",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Get",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Get",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Set:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Set",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Set",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Set",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Del:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Del",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Del",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Del",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Keys:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetKeys()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Keys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Keys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKeys()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Keys",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Mget:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetMget()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Mget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Mget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMget()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Mget",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hget:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHget()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHget()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hget",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hmget:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHmget()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hmget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hmget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHmget()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hmget",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hgetall:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHgetall()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hgetall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hgetall",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHgetall()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hgetall",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hset:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHset()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hset",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHset()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hset",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hsetnx:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHsetnx()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hsetnx",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hsetnx",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHsetnx()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hsetnx",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hlen:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHlen()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hlen",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hlen",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHlen()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hlen",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hdel:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHdel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hdel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hdel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHdel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hdel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hkeys:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHkeys()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hkeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hkeys",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHkeys()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hkeys",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Hvals:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHvals()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hvals",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Hvals",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHvals()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Hvals",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Lindex:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLindex()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lindex",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lindex",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLindex()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Lindex",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Llen:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLlen()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Llen",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Llen",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLlen()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Llen",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Lpush:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLpush()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lpush",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lpush",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLpush()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Lpush",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Lrem:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLrem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lrem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lrem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLrem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Lrem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Lrange:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLrange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lrange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Lrange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLrange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Lrange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Sadd:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSadd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Sadd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Sadd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSadd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Sadd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Scard:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Scard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Scard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Scard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Smembers:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSmembers()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Smembers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Smembers",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSmembers()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Smembers",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Sismember:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSismember()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Sismember",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Sismember",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSismember()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Sismember",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Srandmember:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSrandmember()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Srandmember",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Srandmember",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSrandmember()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Srandmember",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Srem:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSrem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Srem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Srem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSrem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Srem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zadd:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZadd()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zadd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zadd",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZadd()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zadd",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zcard:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZcard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zcard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zcard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZcard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zcard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zcount:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZcount()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zcount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zcount",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZcount()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zcount",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zrange:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZrange()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zrange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zrange",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZrange()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zrange",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zrank:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZrank()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zrank",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zrank",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZrank()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zrank",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zrem:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZrem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zrem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zrem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZrem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zrem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Zscore:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZscore()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zscore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Zscore",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZscore()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Zscore",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Expire:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetExpire()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Expire",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Expire",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetExpire()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Expire",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Structured_Ttl:
		if v == nil {
			err := Plugin_StructuredValidationError{
				field:  "Action",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTtl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Ttl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_StructuredValidationError{
						field:  "Ttl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTtl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_StructuredValidationError{
					field:  "Ttl",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return Plugin_StructuredMultiError(errors)
	}

	return nil
}

// Plugin_StructuredMultiError is an error wrapping multiple validation errors
// returned by Plugin_Structured.ValidateAll() if the designated constraints
// aren't met.
type Plugin_StructuredMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_StructuredMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_StructuredMultiError) AllErrors() []error { return m }

// Plugin_StructuredValidationError is the validation error returned by
// Plugin_Structured.Validate if the designated constraints aren't met.
type Plugin_StructuredValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_StructuredValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_StructuredValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_StructuredValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_StructuredValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_StructuredValidationError) ErrorName() string {
	return "Plugin_StructuredValidationError"
}

// Error satisfies the builtin error interface
func (e Plugin_StructuredValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Structured.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_StructuredValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_StructuredValidationError{}

// Validate checks the field values on Plugin_Connection with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Connection) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Connection with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_ConnectionMultiError, or nil if none found.
func (m *Plugin_Connection) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Connection) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.ConnectionType.(type) {
	case *Plugin_Connection_Url_:
		if v == nil {
			err := Plugin_ConnectionValidationError{
				field:  "ConnectionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUrl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_ConnectionValidationError{
						field:  "Url",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_ConnectionValidationError{
						field:  "Url",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUrl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_ConnectionValidationError{
					field:  "Url",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Plugin_Connection_Fields_:
		if v == nil {
			err := Plugin_ConnectionValidationError{
				field:  "ConnectionType",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFields()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Plugin_ConnectionValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Plugin_ConnectionValidationError{
						field:  "Fields",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFields()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Plugin_ConnectionValidationError{
					field:  "Fields",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return Plugin_ConnectionMultiError(errors)
	}

	return nil
}

// Plugin_ConnectionMultiError is an error wrapping multiple validation errors
// returned by Plugin_Connection.ValidateAll() if the designated constraints
// aren't met.
type Plugin_ConnectionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ConnectionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ConnectionMultiError) AllErrors() []error { return m }

// Plugin_ConnectionValidationError is the validation error returned by
// Plugin_Connection.Validate if the designated constraints aren't met.
type Plugin_ConnectionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ConnectionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ConnectionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ConnectionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ConnectionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ConnectionValidationError) ErrorName() string {
	return "Plugin_ConnectionValidationError"
}

// Error satisfies the builtin error interface
func (e Plugin_ConnectionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Connection.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ConnectionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ConnectionValidationError{}

// Validate checks the field values on Plugin_Get with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Get) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Get with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_GetMultiError, or
// nil if none found.
func (m *Plugin_Get) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Get) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_GetMultiError(errors)
	}

	return nil
}

// Plugin_GetMultiError is an error wrapping multiple validation errors
// returned by Plugin_Get.ValidateAll() if the designated constraints aren't met.
type Plugin_GetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_GetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_GetMultiError) AllErrors() []error { return m }

// Plugin_GetValidationError is the validation error returned by
// Plugin_Get.Validate if the designated constraints aren't met.
type Plugin_GetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_GetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_GetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_GetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_GetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_GetValidationError) ErrorName() string { return "Plugin_GetValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_GetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Get.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_GetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_GetValidationError{}

// Validate checks the field values on Plugin_Set with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Set) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Set with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_SetMultiError, or
// nil if none found.
func (m *Plugin_Set) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Set) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if m.ExpirationMs != nil {
		// no validation rules for ExpirationMs
	}

	if len(errors) > 0 {
		return Plugin_SetMultiError(errors)
	}

	return nil
}

// Plugin_SetMultiError is an error wrapping multiple validation errors
// returned by Plugin_Set.ValidateAll() if the designated constraints aren't met.
type Plugin_SetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_SetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_SetMultiError) AllErrors() []error { return m }

// Plugin_SetValidationError is the validation error returned by
// Plugin_Set.Validate if the designated constraints aren't met.
type Plugin_SetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_SetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_SetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_SetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_SetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_SetValidationError) ErrorName() string { return "Plugin_SetValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_SetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Set.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_SetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_SetValidationError{}

// Validate checks the field values on Plugin_Del with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Del) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Del with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_DelMultiError, or
// nil if none found.
func (m *Plugin_Del) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Del) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_DelMultiError(errors)
	}

	return nil
}

// Plugin_DelMultiError is an error wrapping multiple validation errors
// returned by Plugin_Del.ValidateAll() if the designated constraints aren't met.
type Plugin_DelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_DelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_DelMultiError) AllErrors() []error { return m }

// Plugin_DelValidationError is the validation error returned by
// Plugin_Del.Validate if the designated constraints aren't met.
type Plugin_DelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_DelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_DelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_DelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_DelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_DelValidationError) ErrorName() string { return "Plugin_DelValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_DelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Del.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_DelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_DelValidationError{}

// Validate checks the field values on Plugin_Keys with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Keys) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Keys with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_KeysMultiError, or
// nil if none found.
func (m *Plugin_Keys) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Keys) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Pattern

	if len(errors) > 0 {
		return Plugin_KeysMultiError(errors)
	}

	return nil
}

// Plugin_KeysMultiError is an error wrapping multiple validation errors
// returned by Plugin_Keys.ValidateAll() if the designated constraints aren't met.
type Plugin_KeysMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_KeysMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_KeysMultiError) AllErrors() []error { return m }

// Plugin_KeysValidationError is the validation error returned by
// Plugin_Keys.Validate if the designated constraints aren't met.
type Plugin_KeysValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_KeysValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_KeysValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_KeysValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_KeysValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_KeysValidationError) ErrorName() string { return "Plugin_KeysValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_KeysValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Keys.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_KeysValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_KeysValidationError{}

// Validate checks the field values on Plugin_Mget with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Mget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Mget with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_MgetMultiError, or
// nil if none found.
func (m *Plugin_Mget) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Mget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Keys

	if len(errors) > 0 {
		return Plugin_MgetMultiError(errors)
	}

	return nil
}

// Plugin_MgetMultiError is an error wrapping multiple validation errors
// returned by Plugin_Mget.ValidateAll() if the designated constraints aren't met.
type Plugin_MgetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_MgetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_MgetMultiError) AllErrors() []error { return m }

// Plugin_MgetValidationError is the validation error returned by
// Plugin_Mget.Validate if the designated constraints aren't met.
type Plugin_MgetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_MgetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_MgetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_MgetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_MgetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_MgetValidationError) ErrorName() string { return "Plugin_MgetValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_MgetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Mget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_MgetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_MgetValidationError{}

// Validate checks the field values on Plugin_Hget with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hget with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HgetMultiError, or
// nil if none found.
func (m *Plugin_Hget) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Field

	if len(errors) > 0 {
		return Plugin_HgetMultiError(errors)
	}

	return nil
}

// Plugin_HgetMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hget.ValidateAll() if the designated constraints aren't met.
type Plugin_HgetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HgetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HgetMultiError) AllErrors() []error { return m }

// Plugin_HgetValidationError is the validation error returned by
// Plugin_Hget.Validate if the designated constraints aren't met.
type Plugin_HgetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HgetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HgetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HgetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HgetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HgetValidationError) ErrorName() string { return "Plugin_HgetValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HgetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HgetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HgetValidationError{}

// Validate checks the field values on Plugin_Hmget with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hmget) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hmget with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HmgetMultiError, or
// nil if none found.
func (m *Plugin_Hmget) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hmget) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Fields

	if len(errors) > 0 {
		return Plugin_HmgetMultiError(errors)
	}

	return nil
}

// Plugin_HmgetMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hmget.ValidateAll() if the designated constraints aren't met.
type Plugin_HmgetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HmgetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HmgetMultiError) AllErrors() []error { return m }

// Plugin_HmgetValidationError is the validation error returned by
// Plugin_Hmget.Validate if the designated constraints aren't met.
type Plugin_HmgetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HmgetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HmgetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HmgetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HmgetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HmgetValidationError) ErrorName() string { return "Plugin_HmgetValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HmgetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hmget.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HmgetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HmgetValidationError{}

// Validate checks the field values on Plugin_Hgetall with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hgetall) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hgetall with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HgetallMultiError,
// or nil if none found.
func (m *Plugin_Hgetall) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hgetall) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_HgetallMultiError(errors)
	}

	return nil
}

// Plugin_HgetallMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hgetall.ValidateAll() if the designated constraints
// aren't met.
type Plugin_HgetallMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HgetallMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HgetallMultiError) AllErrors() []error { return m }

// Plugin_HgetallValidationError is the validation error returned by
// Plugin_Hgetall.Validate if the designated constraints aren't met.
type Plugin_HgetallValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HgetallValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HgetallValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HgetallValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HgetallValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HgetallValidationError) ErrorName() string { return "Plugin_HgetallValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HgetallValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hgetall.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HgetallValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HgetallValidationError{}

// Validate checks the field values on Plugin_Hset with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hset) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hset with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HsetMultiError, or
// nil if none found.
func (m *Plugin_Hset) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hset) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Field

	// no validation rules for Value

	if len(errors) > 0 {
		return Plugin_HsetMultiError(errors)
	}

	return nil
}

// Plugin_HsetMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hset.ValidateAll() if the designated constraints aren't met.
type Plugin_HsetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HsetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HsetMultiError) AllErrors() []error { return m }

// Plugin_HsetValidationError is the validation error returned by
// Plugin_Hset.Validate if the designated constraints aren't met.
type Plugin_HsetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HsetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HsetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HsetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HsetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HsetValidationError) ErrorName() string { return "Plugin_HsetValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HsetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hset.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HsetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HsetValidationError{}

// Validate checks the field values on Plugin_Hsetnx with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hsetnx) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hsetnx with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HsetnxMultiError, or
// nil if none found.
func (m *Plugin_Hsetnx) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hsetnx) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Field

	// no validation rules for Value

	if len(errors) > 0 {
		return Plugin_HsetnxMultiError(errors)
	}

	return nil
}

// Plugin_HsetnxMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hsetnx.ValidateAll() if the designated constraints
// aren't met.
type Plugin_HsetnxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HsetnxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HsetnxMultiError) AllErrors() []error { return m }

// Plugin_HsetnxValidationError is the validation error returned by
// Plugin_Hsetnx.Validate if the designated constraints aren't met.
type Plugin_HsetnxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HsetnxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HsetnxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HsetnxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HsetnxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HsetnxValidationError) ErrorName() string { return "Plugin_HsetnxValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HsetnxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hsetnx.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HsetnxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HsetnxValidationError{}

// Validate checks the field values on Plugin_Hlen with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hlen) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hlen with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HlenMultiError, or
// nil if none found.
func (m *Plugin_Hlen) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hlen) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_HlenMultiError(errors)
	}

	return nil
}

// Plugin_HlenMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hlen.ValidateAll() if the designated constraints aren't met.
type Plugin_HlenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HlenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HlenMultiError) AllErrors() []error { return m }

// Plugin_HlenValidationError is the validation error returned by
// Plugin_Hlen.Validate if the designated constraints aren't met.
type Plugin_HlenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HlenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HlenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HlenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HlenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HlenValidationError) ErrorName() string { return "Plugin_HlenValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HlenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hlen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HlenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HlenValidationError{}

// Validate checks the field values on Plugin_Hdel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hdel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hdel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HdelMultiError, or
// nil if none found.
func (m *Plugin_Hdel) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hdel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Field

	if len(errors) > 0 {
		return Plugin_HdelMultiError(errors)
	}

	return nil
}

// Plugin_HdelMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hdel.ValidateAll() if the designated constraints aren't met.
type Plugin_HdelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HdelMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HdelMultiError) AllErrors() []error { return m }

// Plugin_HdelValidationError is the validation error returned by
// Plugin_Hdel.Validate if the designated constraints aren't met.
type Plugin_HdelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HdelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HdelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HdelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HdelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HdelValidationError) ErrorName() string { return "Plugin_HdelValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HdelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hdel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HdelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HdelValidationError{}

// Validate checks the field values on Plugin_Hkeys with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hkeys) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hkeys with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HkeysMultiError, or
// nil if none found.
func (m *Plugin_Hkeys) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hkeys) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_HkeysMultiError(errors)
	}

	return nil
}

// Plugin_HkeysMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hkeys.ValidateAll() if the designated constraints aren't met.
type Plugin_HkeysMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HkeysMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HkeysMultiError) AllErrors() []error { return m }

// Plugin_HkeysValidationError is the validation error returned by
// Plugin_Hkeys.Validate if the designated constraints aren't met.
type Plugin_HkeysValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HkeysValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HkeysValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HkeysValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HkeysValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HkeysValidationError) ErrorName() string { return "Plugin_HkeysValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HkeysValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hkeys.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HkeysValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HkeysValidationError{}

// Validate checks the field values on Plugin_Hvals with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Hvals) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Hvals with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_HvalsMultiError, or
// nil if none found.
func (m *Plugin_Hvals) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Hvals) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_HvalsMultiError(errors)
	}

	return nil
}

// Plugin_HvalsMultiError is an error wrapping multiple validation errors
// returned by Plugin_Hvals.ValidateAll() if the designated constraints aren't met.
type Plugin_HvalsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_HvalsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_HvalsMultiError) AllErrors() []error { return m }

// Plugin_HvalsValidationError is the validation error returned by
// Plugin_Hvals.Validate if the designated constraints aren't met.
type Plugin_HvalsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_HvalsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_HvalsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_HvalsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_HvalsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_HvalsValidationError) ErrorName() string { return "Plugin_HvalsValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_HvalsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Hvals.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_HvalsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_HvalsValidationError{}

// Validate checks the field values on Plugin_Lindex with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Lindex) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Lindex with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_LindexMultiError, or
// nil if none found.
func (m *Plugin_Lindex) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Lindex) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Index

	if len(errors) > 0 {
		return Plugin_LindexMultiError(errors)
	}

	return nil
}

// Plugin_LindexMultiError is an error wrapping multiple validation errors
// returned by Plugin_Lindex.ValidateAll() if the designated constraints
// aren't met.
type Plugin_LindexMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_LindexMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_LindexMultiError) AllErrors() []error { return m }

// Plugin_LindexValidationError is the validation error returned by
// Plugin_Lindex.Validate if the designated constraints aren't met.
type Plugin_LindexValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_LindexValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_LindexValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_LindexValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_LindexValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_LindexValidationError) ErrorName() string { return "Plugin_LindexValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_LindexValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Lindex.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_LindexValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_LindexValidationError{}

// Validate checks the field values on Plugin_Llen with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Llen) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Llen with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_LlenMultiError, or
// nil if none found.
func (m *Plugin_Llen) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Llen) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_LlenMultiError(errors)
	}

	return nil
}

// Plugin_LlenMultiError is an error wrapping multiple validation errors
// returned by Plugin_Llen.ValidateAll() if the designated constraints aren't met.
type Plugin_LlenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_LlenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_LlenMultiError) AllErrors() []error { return m }

// Plugin_LlenValidationError is the validation error returned by
// Plugin_Llen.Validate if the designated constraints aren't met.
type Plugin_LlenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_LlenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_LlenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_LlenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_LlenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_LlenValidationError) ErrorName() string { return "Plugin_LlenValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_LlenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Llen.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_LlenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_LlenValidationError{}

// Validate checks the field values on Plugin_Lpush with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Lpush) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Lpush with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_LpushMultiError, or
// nil if none found.
func (m *Plugin_Lpush) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Lpush) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Value

	if len(errors) > 0 {
		return Plugin_LpushMultiError(errors)
	}

	return nil
}

// Plugin_LpushMultiError is an error wrapping multiple validation errors
// returned by Plugin_Lpush.ValidateAll() if the designated constraints aren't met.
type Plugin_LpushMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_LpushMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_LpushMultiError) AllErrors() []error { return m }

// Plugin_LpushValidationError is the validation error returned by
// Plugin_Lpush.Validate if the designated constraints aren't met.
type Plugin_LpushValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_LpushValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_LpushValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_LpushValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_LpushValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_LpushValidationError) ErrorName() string { return "Plugin_LpushValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_LpushValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Lpush.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_LpushValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_LpushValidationError{}

// Validate checks the field values on Plugin_Lrem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Lrem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Lrem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_LremMultiError, or
// nil if none found.
func (m *Plugin_Lrem) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Lrem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Count

	// no validation rules for Value

	if len(errors) > 0 {
		return Plugin_LremMultiError(errors)
	}

	return nil
}

// Plugin_LremMultiError is an error wrapping multiple validation errors
// returned by Plugin_Lrem.ValidateAll() if the designated constraints aren't met.
type Plugin_LremMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_LremMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_LremMultiError) AllErrors() []error { return m }

// Plugin_LremValidationError is the validation error returned by
// Plugin_Lrem.Validate if the designated constraints aren't met.
type Plugin_LremValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_LremValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_LremValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_LremValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_LremValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_LremValidationError) ErrorName() string { return "Plugin_LremValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_LremValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Lrem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_LremValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_LremValidationError{}

// Validate checks the field values on Plugin_Lrange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Lrange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Lrange with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_LrangeMultiError, or
// nil if none found.
func (m *Plugin_Lrange) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Lrange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Start

	// no validation rules for Stop

	if len(errors) > 0 {
		return Plugin_LrangeMultiError(errors)
	}

	return nil
}

// Plugin_LrangeMultiError is an error wrapping multiple validation errors
// returned by Plugin_Lrange.ValidateAll() if the designated constraints
// aren't met.
type Plugin_LrangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_LrangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_LrangeMultiError) AllErrors() []error { return m }

// Plugin_LrangeValidationError is the validation error returned by
// Plugin_Lrange.Validate if the designated constraints aren't met.
type Plugin_LrangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_LrangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_LrangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_LrangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_LrangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_LrangeValidationError) ErrorName() string { return "Plugin_LrangeValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_LrangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Lrange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_LrangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_LrangeValidationError{}

// Validate checks the field values on Plugin_Sadd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Sadd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Sadd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_SaddMultiError, or
// nil if none found.
func (m *Plugin_Sadd) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Sadd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_SaddMultiError(errors)
	}

	return nil
}

// Plugin_SaddMultiError is an error wrapping multiple validation errors
// returned by Plugin_Sadd.ValidateAll() if the designated constraints aren't met.
type Plugin_SaddMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_SaddMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_SaddMultiError) AllErrors() []error { return m }

// Plugin_SaddValidationError is the validation error returned by
// Plugin_Sadd.Validate if the designated constraints aren't met.
type Plugin_SaddValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_SaddValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_SaddValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_SaddValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_SaddValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_SaddValidationError) ErrorName() string { return "Plugin_SaddValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_SaddValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Sadd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_SaddValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_SaddValidationError{}

// Validate checks the field values on Plugin_Scard with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Scard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Scard with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ScardMultiError, or
// nil if none found.
func (m *Plugin_Scard) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Scard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_ScardMultiError(errors)
	}

	return nil
}

// Plugin_ScardMultiError is an error wrapping multiple validation errors
// returned by Plugin_Scard.ValidateAll() if the designated constraints aren't met.
type Plugin_ScardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ScardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ScardMultiError) AllErrors() []error { return m }

// Plugin_ScardValidationError is the validation error returned by
// Plugin_Scard.Validate if the designated constraints aren't met.
type Plugin_ScardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ScardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ScardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ScardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ScardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ScardValidationError) ErrorName() string { return "Plugin_ScardValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ScardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Scard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ScardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ScardValidationError{}

// Validate checks the field values on Plugin_Smembers with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Smembers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Smembers with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_SmembersMultiError, or nil if none found.
func (m *Plugin_Smembers) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Smembers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_SmembersMultiError(errors)
	}

	return nil
}

// Plugin_SmembersMultiError is an error wrapping multiple validation errors
// returned by Plugin_Smembers.ValidateAll() if the designated constraints
// aren't met.
type Plugin_SmembersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_SmembersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_SmembersMultiError) AllErrors() []error { return m }

// Plugin_SmembersValidationError is the validation error returned by
// Plugin_Smembers.Validate if the designated constraints aren't met.
type Plugin_SmembersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_SmembersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_SmembersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_SmembersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_SmembersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_SmembersValidationError) ErrorName() string { return "Plugin_SmembersValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_SmembersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Smembers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_SmembersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_SmembersValidationError{}

// Validate checks the field values on Plugin_Sismember with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Sismember) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Sismember with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_SismemberMultiError, or nil if none found.
func (m *Plugin_Sismember) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Sismember) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_SismemberMultiError(errors)
	}

	return nil
}

// Plugin_SismemberMultiError is an error wrapping multiple validation errors
// returned by Plugin_Sismember.ValidateAll() if the designated constraints
// aren't met.
type Plugin_SismemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_SismemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_SismemberMultiError) AllErrors() []error { return m }

// Plugin_SismemberValidationError is the validation error returned by
// Plugin_Sismember.Validate if the designated constraints aren't met.
type Plugin_SismemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_SismemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_SismemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_SismemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_SismemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_SismemberValidationError) ErrorName() string { return "Plugin_SismemberValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_SismemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Sismember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_SismemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_SismemberValidationError{}

// Validate checks the field values on Plugin_Srandmember with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Srandmember) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Srandmember with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_SrandmemberMultiError, or nil if none found.
func (m *Plugin_Srandmember) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Srandmember) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if m.Count != nil {
		// no validation rules for Count
	}

	if len(errors) > 0 {
		return Plugin_SrandmemberMultiError(errors)
	}

	return nil
}

// Plugin_SrandmemberMultiError is an error wrapping multiple validation errors
// returned by Plugin_Srandmember.ValidateAll() if the designated constraints
// aren't met.
type Plugin_SrandmemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_SrandmemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_SrandmemberMultiError) AllErrors() []error { return m }

// Plugin_SrandmemberValidationError is the validation error returned by
// Plugin_Srandmember.Validate if the designated constraints aren't met.
type Plugin_SrandmemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_SrandmemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_SrandmemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_SrandmemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_SrandmemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_SrandmemberValidationError) ErrorName() string {
	return "Plugin_SrandmemberValidationError"
}

// Error satisfies the builtin error interface
func (e Plugin_SrandmemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Srandmember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_SrandmemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_SrandmemberValidationError{}

// Validate checks the field values on Plugin_Srem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Srem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Srem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_SremMultiError, or
// nil if none found.
func (m *Plugin_Srem) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Srem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_SremMultiError(errors)
	}

	return nil
}

// Plugin_SremMultiError is an error wrapping multiple validation errors
// returned by Plugin_Srem.ValidateAll() if the designated constraints aren't met.
type Plugin_SremMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_SremMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_SremMultiError) AllErrors() []error { return m }

// Plugin_SremValidationError is the validation error returned by
// Plugin_Srem.Validate if the designated constraints aren't met.
type Plugin_SremValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_SremValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_SremValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_SremValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_SremValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_SremValidationError) ErrorName() string { return "Plugin_SremValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_SremValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Srem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_SremValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_SremValidationError{}

// Validate checks the field values on Plugin_Zadd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zadd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zadd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZaddMultiError, or
// nil if none found.
func (m *Plugin_Zadd) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zadd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Score

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_ZaddMultiError(errors)
	}

	return nil
}

// Plugin_ZaddMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zadd.ValidateAll() if the designated constraints aren't met.
type Plugin_ZaddMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZaddMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZaddMultiError) AllErrors() []error { return m }

// Plugin_ZaddValidationError is the validation error returned by
// Plugin_Zadd.Validate if the designated constraints aren't met.
type Plugin_ZaddValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZaddValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZaddValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZaddValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZaddValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZaddValidationError) ErrorName() string { return "Plugin_ZaddValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZaddValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zadd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZaddValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZaddValidationError{}

// Validate checks the field values on Plugin_Zcard with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zcard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zcard with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZcardMultiError, or
// nil if none found.
func (m *Plugin_Zcard) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zcard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_ZcardMultiError(errors)
	}

	return nil
}

// Plugin_ZcardMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zcard.ValidateAll() if the designated constraints aren't met.
type Plugin_ZcardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZcardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZcardMultiError) AllErrors() []error { return m }

// Plugin_ZcardValidationError is the validation error returned by
// Plugin_Zcard.Validate if the designated constraints aren't met.
type Plugin_ZcardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZcardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZcardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZcardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZcardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZcardValidationError) ErrorName() string { return "Plugin_ZcardValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZcardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zcard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZcardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZcardValidationError{}

// Validate checks the field values on Plugin_Zcount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zcount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zcount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZcountMultiError, or
// nil if none found.
func (m *Plugin_Zcount) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zcount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return Plugin_ZcountMultiError(errors)
	}

	return nil
}

// Plugin_ZcountMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zcount.ValidateAll() if the designated constraints
// aren't met.
type Plugin_ZcountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZcountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZcountMultiError) AllErrors() []error { return m }

// Plugin_ZcountValidationError is the validation error returned by
// Plugin_Zcount.Validate if the designated constraints aren't met.
type Plugin_ZcountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZcountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZcountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZcountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZcountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZcountValidationError) ErrorName() string { return "Plugin_ZcountValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZcountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zcount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZcountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZcountValidationError{}

// Validate checks the field values on Plugin_Zrange with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zrange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zrange with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZrangeMultiError, or
// nil if none found.
func (m *Plugin_Zrange) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zrange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Start

	// no validation rules for Stop

	if len(errors) > 0 {
		return Plugin_ZrangeMultiError(errors)
	}

	return nil
}

// Plugin_ZrangeMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zrange.ValidateAll() if the designated constraints
// aren't met.
type Plugin_ZrangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZrangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZrangeMultiError) AllErrors() []error { return m }

// Plugin_ZrangeValidationError is the validation error returned by
// Plugin_Zrange.Validate if the designated constraints aren't met.
type Plugin_ZrangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZrangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZrangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZrangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZrangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZrangeValidationError) ErrorName() string { return "Plugin_ZrangeValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZrangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zrange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZrangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZrangeValidationError{}

// Validate checks the field values on Plugin_Zrank with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zrank) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zrank with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZrankMultiError, or
// nil if none found.
func (m *Plugin_Zrank) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zrank) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_ZrankMultiError(errors)
	}

	return nil
}

// Plugin_ZrankMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zrank.ValidateAll() if the designated constraints aren't met.
type Plugin_ZrankMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZrankMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZrankMultiError) AllErrors() []error { return m }

// Plugin_ZrankValidationError is the validation error returned by
// Plugin_Zrank.Validate if the designated constraints aren't met.
type Plugin_ZrankValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZrankValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZrankValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZrankValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZrankValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZrankValidationError) ErrorName() string { return "Plugin_ZrankValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZrankValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zrank.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZrankValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZrankValidationError{}

// Validate checks the field values on Plugin_Zrem with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zrem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zrem with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZremMultiError, or
// nil if none found.
func (m *Plugin_Zrem) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zrem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_ZremMultiError(errors)
	}

	return nil
}

// Plugin_ZremMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zrem.ValidateAll() if the designated constraints aren't met.
type Plugin_ZremMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZremMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZremMultiError) AllErrors() []error { return m }

// Plugin_ZremValidationError is the validation error returned by
// Plugin_Zrem.Validate if the designated constraints aren't met.
type Plugin_ZremValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZremValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZremValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZremValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZremValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZremValidationError) ErrorName() string { return "Plugin_ZremValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZremValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zrem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZremValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZremValidationError{}

// Validate checks the field values on Plugin_Zscore with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Zscore) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Zscore with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ZscoreMultiError, or
// nil if none found.
func (m *Plugin_Zscore) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Zscore) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Member

	if len(errors) > 0 {
		return Plugin_ZscoreMultiError(errors)
	}

	return nil
}

// Plugin_ZscoreMultiError is an error wrapping multiple validation errors
// returned by Plugin_Zscore.ValidateAll() if the designated constraints
// aren't met.
type Plugin_ZscoreMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ZscoreMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ZscoreMultiError) AllErrors() []error { return m }

// Plugin_ZscoreValidationError is the validation error returned by
// Plugin_Zscore.Validate if the designated constraints aren't met.
type Plugin_ZscoreValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ZscoreValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ZscoreValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ZscoreValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ZscoreValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ZscoreValidationError) ErrorName() string { return "Plugin_ZscoreValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ZscoreValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Zscore.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ZscoreValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ZscoreValidationError{}

// Validate checks the field values on Plugin_Expire with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Expire) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Expire with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_ExpireMultiError, or
// nil if none found.
func (m *Plugin_Expire) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Expire) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Seconds

	if m.Option != nil {
		// no validation rules for Option
	}

	if len(errors) > 0 {
		return Plugin_ExpireMultiError(errors)
	}

	return nil
}

// Plugin_ExpireMultiError is an error wrapping multiple validation errors
// returned by Plugin_Expire.ValidateAll() if the designated constraints
// aren't met.
type Plugin_ExpireMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_ExpireMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_ExpireMultiError) AllErrors() []error { return m }

// Plugin_ExpireValidationError is the validation error returned by
// Plugin_Expire.Validate if the designated constraints aren't met.
type Plugin_ExpireValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_ExpireValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_ExpireValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_ExpireValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_ExpireValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_ExpireValidationError) ErrorName() string { return "Plugin_ExpireValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_ExpireValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Expire.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_ExpireValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_ExpireValidationError{}

// Validate checks the field values on Plugin_Ttl with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Plugin_Ttl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Ttl with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Plugin_TtlMultiError, or
// nil if none found.
func (m *Plugin_Ttl) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Ttl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return Plugin_TtlMultiError(errors)
	}

	return nil
}

// Plugin_TtlMultiError is an error wrapping multiple validation errors
// returned by Plugin_Ttl.ValidateAll() if the designated constraints aren't met.
type Plugin_TtlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_TtlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_TtlMultiError) AllErrors() []error { return m }

// Plugin_TtlValidationError is the validation error returned by
// Plugin_Ttl.Validate if the designated constraints aren't met.
type Plugin_TtlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_TtlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_TtlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_TtlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_TtlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_TtlValidationError) ErrorName() string { return "Plugin_TtlValidationError" }

// Error satisfies the builtin error interface
func (e Plugin_TtlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Ttl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_TtlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_TtlValidationError{}

// Validate checks the field values on Plugin_Raw_Singleton with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Raw_Singleton) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Raw_Singleton with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_Raw_SingletonMultiError, or nil if none found.
func (m *Plugin_Raw_Singleton) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Raw_Singleton) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Query

	if len(errors) > 0 {
		return Plugin_Raw_SingletonMultiError(errors)
	}

	return nil
}

// Plugin_Raw_SingletonMultiError is an error wrapping multiple validation
// errors returned by Plugin_Raw_Singleton.ValidateAll() if the designated
// constraints aren't met.
type Plugin_Raw_SingletonMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_Raw_SingletonMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_Raw_SingletonMultiError) AllErrors() []error { return m }

// Plugin_Raw_SingletonValidationError is the validation error returned by
// Plugin_Raw_Singleton.Validate if the designated constraints aren't met.
type Plugin_Raw_SingletonValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_Raw_SingletonValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_Raw_SingletonValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_Raw_SingletonValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_Raw_SingletonValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_Raw_SingletonValidationError) ErrorName() string {
	return "Plugin_Raw_SingletonValidationError"
}

// Error satisfies the builtin error interface
func (e Plugin_Raw_SingletonValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Raw_Singleton.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_Raw_SingletonValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_Raw_SingletonValidationError{}

// Validate checks the field values on Plugin_Connection_Url with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Connection_Url) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Connection_Url with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_Connection_UrlMultiError, or nil if none found.
func (m *Plugin_Connection_Url) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Connection_Url) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for UrlString

	if len(errors) > 0 {
		return Plugin_Connection_UrlMultiError(errors)
	}

	return nil
}

// Plugin_Connection_UrlMultiError is an error wrapping multiple validation
// errors returned by Plugin_Connection_Url.ValidateAll() if the designated
// constraints aren't met.
type Plugin_Connection_UrlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_Connection_UrlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_Connection_UrlMultiError) AllErrors() []error { return m }

// Plugin_Connection_UrlValidationError is the validation error returned by
// Plugin_Connection_Url.Validate if the designated constraints aren't met.
type Plugin_Connection_UrlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_Connection_UrlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_Connection_UrlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_Connection_UrlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_Connection_UrlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_Connection_UrlValidationError) ErrorName() string {
	return "Plugin_Connection_UrlValidationError"
}

// Error satisfies the builtin error interface
func (e Plugin_Connection_UrlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Connection_Url.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_Connection_UrlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_Connection_UrlValidationError{}

// Validate checks the field values on Plugin_Connection_Fields with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Plugin_Connection_Fields) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Plugin_Connection_Fields with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Plugin_Connection_FieldsMultiError, or nil if none found.
func (m *Plugin_Connection_Fields) ValidateAll() error {
	return m.validate(true)
}

func (m *Plugin_Connection_Fields) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Host

	// no validation rules for Port

	// no validation rules for EnableSsl

	if m.DatabaseNumber != nil {
		// no validation rules for DatabaseNumber
	}

	if m.Username != nil {
		// no validation rules for Username
	}

	if m.Password != nil {
		// no validation rules for Password
	}

	if len(errors) > 0 {
		return Plugin_Connection_FieldsMultiError(errors)
	}

	return nil
}

// Plugin_Connection_FieldsMultiError is an error wrapping multiple validation
// errors returned by Plugin_Connection_Fields.ValidateAll() if the designated
// constraints aren't met.
type Plugin_Connection_FieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Plugin_Connection_FieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Plugin_Connection_FieldsMultiError) AllErrors() []error { return m }

// Plugin_Connection_FieldsValidationError is the validation error returned by
// Plugin_Connection_Fields.Validate if the designated constraints aren't met.
type Plugin_Connection_FieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Plugin_Connection_FieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Plugin_Connection_FieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Plugin_Connection_FieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Plugin_Connection_FieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Plugin_Connection_FieldsValidationError) ErrorName() string {
	return "Plugin_Connection_FieldsValidationError"
}

// Error satisfies the builtin error interface
func (e Plugin_Connection_FieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPlugin_Connection_Fields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Plugin_Connection_FieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Plugin_Connection_FieldsValidationError{}
