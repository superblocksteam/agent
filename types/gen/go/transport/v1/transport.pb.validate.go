// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: transport/v1/transport.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	v1 "github.com/superblocksteam/agent/types/gen/go/api/v1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = v1.Variables_Type(0)
)

// Validate checks the field values on Performance with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Performance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Performance with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PerformanceMultiError, or
// nil if none found.
func (m *Performance) ValidateAll() error {
	return m.validate(true)
}

func (m *Performance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	if all {
		switch v := interface{}(m.GetPluginExecution()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "PluginExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "PluginExecution",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPluginExecution()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerformanceValidationError{
				field:  "PluginExecution",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQueueRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "QueueRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "QueueRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerformanceValidationError{
				field:  "QueueRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQueueResponse()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "QueueResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "QueueResponse",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueResponse()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerformanceValidationError{
				field:  "QueueResponse",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKvStoreFetch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "KvStoreFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "KvStoreFetch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKvStoreFetch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerformanceValidationError{
				field:  "KvStoreFetch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKvStorePush()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "KvStorePush",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "KvStorePush",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKvStorePush()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerformanceValidationError{
				field:  "KvStorePush",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTotal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PerformanceValidationError{
					field:  "Total",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTotal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PerformanceValidationError{
				field:  "Total",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PerformanceMultiError(errors)
	}

	return nil
}

// PerformanceMultiError is an error wrapping multiple validation errors
// returned by Performance.ValidateAll() if the designated constraints aren't met.
type PerformanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PerformanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PerformanceMultiError) AllErrors() []error { return m }

// PerformanceValidationError is the validation error returned by
// Performance.Validate if the designated constraints aren't met.
type PerformanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PerformanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PerformanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PerformanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PerformanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PerformanceValidationError) ErrorName() string { return "PerformanceValidationError" }

// Error satisfies the builtin error interface
func (e PerformanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPerformance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PerformanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PerformanceValidationError{}

// Validate checks the field values on Variable with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Variable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Variable with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in VariableMultiError, or nil
// if none found.
func (m *Variable) ValidateAll() error {
	return m.validate(true)
}

func (m *Variable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Type

	// no validation rules for Mode

	if len(errors) > 0 {
		return VariableMultiError(errors)
	}

	return nil
}

// VariableMultiError is an error wrapping multiple validation errors returned
// by Variable.ValidateAll() if the designated constraints aren't met.
type VariableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m VariableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m VariableMultiError) AllErrors() []error { return m }

// VariableValidationError is the validation error returned by
// Variable.Validate if the designated constraints aren't met.
type VariableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e VariableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e VariableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e VariableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e VariableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e VariableValidationError) ErrorName() string { return "VariableValidationError" }

// Error satisfies the builtin error interface
func (e VariableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sVariable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = VariableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = VariableValidationError{}

// Validate checks the field values on Observability with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Observability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Observability with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ObservabilityMultiError, or
// nil if none found.
func (m *Observability) ValidateAll() error {
	return m.validate(true)
}

func (m *Observability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TraceId

	// no validation rules for SpanId

	// no validation rules for Baggage

	// no validation rules for TraceFlags

	if len(errors) > 0 {
		return ObservabilityMultiError(errors)
	}

	return nil
}

// ObservabilityMultiError is an error wrapping multiple validation errors
// returned by Observability.ValidateAll() if the designated constraints
// aren't met.
type ObservabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObservabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObservabilityMultiError) AllErrors() []error { return m }

// ObservabilityValidationError is the validation error returned by
// Observability.Validate if the designated constraints aren't met.
type ObservabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObservabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObservabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObservabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObservabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObservabilityValidationError) ErrorName() string { return "ObservabilityValidationError" }

// Error satisfies the builtin error interface
func (e ObservabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObservability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObservabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObservabilityValidationError{}

// Validate checks the field values on Request with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RequestMultiError, or nil if none found.
func (m *Request) ValidateAll() error {
	return m.validate(true)
}

func (m *Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Inbox

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RequestValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RequestValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Topic

	if len(errors) > 0 {
		return RequestMultiError(errors)
	}

	return nil
}

// RequestMultiError is an error wrapping multiple validation errors returned
// by Request.ValidateAll() if the designated constraints aren't met.
type RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestMultiError) AllErrors() []error { return m }

// RequestValidationError is the validation error returned by Request.Validate
// if the designated constraints aren't met.
type RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestValidationError) ErrorName() string { return "RequestValidationError" }

// Error satisfies the builtin error interface
func (e RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestValidationError{}

// Validate checks the field values on Response with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Response with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResponseMultiError, or nil
// if none found.
func (m *Response) ValidateAll() error {
	return m.validate(true)
}

func (m *Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponseValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPinned()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResponseValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPinned()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResponseValidationError{
				field:  "Pinned",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ResponseMultiError(errors)
	}

	return nil
}

// ResponseMultiError is an error wrapping multiple validation errors returned
// by Response.ValidateAll() if the designated constraints aren't met.
type ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResponseMultiError) AllErrors() []error { return m }

// ResponseValidationError is the validation error returned by
// Response.Validate if the designated constraints aren't met.
type ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResponseValidationError) ErrorName() string { return "ResponseValidationError" }

// Error satisfies the builtin error interface
func (e ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResponseValidationError{}

// Validate checks the field values on Fetch with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Fetch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Fetch with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FetchMultiError, or nil if none found.
func (m *Fetch) ValidateAll() error {
	return m.validate(true)
}

func (m *Fetch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetApi() == nil {
		err := FetchValidationError{
			field:  "Api",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetApi()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FetchValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FetchValidationError{
					field:  "Api",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetApi()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FetchValidationError{
				field:  "Api",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]string, len(m.GetIntegrations()))
		i := 0
		for key := range m.GetIntegrations() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetIntegrations()[key]
			_ = val

			// no validation rules for Integrations[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, FetchValidationError{
							field:  fmt.Sprintf("Integrations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, FetchValidationError{
							field:  fmt.Sprintf("Integrations[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return FetchValidationError{
						field:  fmt.Sprintf("Integrations[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if m.GetMetadata() == nil {
		err := FetchValidationError{
			field:  "Metadata",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FetchValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FetchValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FetchValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStores()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FetchValidationError{
					field:  "Stores",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FetchValidationError{
					field:  "Stores",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStores()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FetchValidationError{
				field:  "Stores",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FetchMultiError(errors)
	}

	return nil
}

// FetchMultiError is an error wrapping multiple validation errors returned by
// Fetch.ValidateAll() if the designated constraints aren't met.
type FetchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FetchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FetchMultiError) AllErrors() []error { return m }

// FetchValidationError is the validation error returned by Fetch.Validate if
// the designated constraints aren't met.
type FetchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FetchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FetchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FetchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FetchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FetchValidationError) ErrorName() string { return "FetchValidationError" }

// Error satisfies the builtin error interface
func (e FetchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFetch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FetchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FetchValidationError{}

// Validate checks the field values on FetchScheduleJobResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FetchScheduleJobResp) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FetchScheduleJobResp with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FetchScheduleJobRespMultiError, or nil if none found.
func (m *FetchScheduleJobResp) ValidateAll() error {
	return m.validate(true)
}

func (m *FetchScheduleJobResp) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetApis() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FetchScheduleJobRespValidationError{
						field:  fmt.Sprintf("Apis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FetchScheduleJobRespValidationError{
						field:  fmt.Sprintf("Apis[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FetchScheduleJobRespValidationError{
					field:  fmt.Sprintf("Apis[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return FetchScheduleJobRespMultiError(errors)
	}

	return nil
}

// FetchScheduleJobRespMultiError is an error wrapping multiple validation
// errors returned by FetchScheduleJobResp.ValidateAll() if the designated
// constraints aren't met.
type FetchScheduleJobRespMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FetchScheduleJobRespMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FetchScheduleJobRespMultiError) AllErrors() []error { return m }

// FetchScheduleJobRespValidationError is the validation error returned by
// FetchScheduleJobResp.Validate if the designated constraints aren't met.
type FetchScheduleJobRespValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FetchScheduleJobRespValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FetchScheduleJobRespValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FetchScheduleJobRespValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FetchScheduleJobRespValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FetchScheduleJobRespValidationError) ErrorName() string {
	return "FetchScheduleJobRespValidationError"
}

// Error satisfies the builtin error interface
func (e FetchScheduleJobRespValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFetchScheduleJobResp.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FetchScheduleJobRespValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FetchScheduleJobRespValidationError{}

// Validate checks the field values on Performance_Observable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Performance_Observable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Performance_Observable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Performance_ObservableMultiError, or nil if none found.
func (m *Performance_Observable) ValidateAll() error {
	return m.validate(true)
}

func (m *Performance_Observable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Start

	// no validation rules for End

	// no validation rules for Value

	// no validation rules for Bytes

	// no validation rules for Estimate

	if len(errors) > 0 {
		return Performance_ObservableMultiError(errors)
	}

	return nil
}

// Performance_ObservableMultiError is an error wrapping multiple validation
// errors returned by Performance_Observable.ValidateAll() if the designated
// constraints aren't met.
type Performance_ObservableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Performance_ObservableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Performance_ObservableMultiError) AllErrors() []error { return m }

// Performance_ObservableValidationError is the validation error returned by
// Performance_Observable.Validate if the designated constraints aren't met.
type Performance_ObservableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Performance_ObservableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Performance_ObservableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Performance_ObservableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Performance_ObservableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Performance_ObservableValidationError) ErrorName() string {
	return "Performance_ObservableValidationError"
}

// Error satisfies the builtin error interface
func (e Performance_ObservableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPerformance_Observable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Performance_ObservableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Performance_ObservableValidationError{}

// Validate checks the field values on Request_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Request_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Request_DataMultiError, or
// nil if none found.
func (m *Request_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPinned()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_DataValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_DataValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPinned()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_DataValidationError{
				field:  "Pinned",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_DataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_DataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_DataValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Request_DataMultiError(errors)
	}

	return nil
}

// Request_DataMultiError is an error wrapping multiple validation errors
// returned by Request_Data.ValidateAll() if the designated constraints aren't met.
type Request_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_DataMultiError) AllErrors() []error { return m }

// Request_DataValidationError is the validation error returned by
// Request_Data.Validate if the designated constraints aren't met.
type Request_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_DataValidationError) ErrorName() string { return "Request_DataValidationError" }

// Error satisfies the builtin error interface
func (e Request_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_DataValidationError{}

// Validate checks the field values on Request_Data_Pinned with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Request_Data_Pinned) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data_Pinned with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Request_Data_PinnedMultiError, or nil if none found.
func (m *Request_Data_Pinned) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data_Pinned) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Bucket

	// no validation rules for Name

	// no validation rules for Version

	// no validation rules for Event

	// no validation rules for Carrier

	if all {
		switch v := interface{}(m.GetObservability()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_Data_PinnedValidationError{
					field:  "Observability",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_Data_PinnedValidationError{
					field:  "Observability",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetObservability()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_Data_PinnedValidationError{
				field:  "Observability",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Request_Data_PinnedMultiError(errors)
	}

	return nil
}

// Request_Data_PinnedMultiError is an error wrapping multiple validation
// errors returned by Request_Data_Pinned.ValidateAll() if the designated
// constraints aren't met.
type Request_Data_PinnedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_Data_PinnedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_Data_PinnedMultiError) AllErrors() []error { return m }

// Request_Data_PinnedValidationError is the validation error returned by
// Request_Data_Pinned.Validate if the designated constraints aren't met.
type Request_Data_PinnedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_Data_PinnedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_Data_PinnedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_Data_PinnedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_Data_PinnedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_Data_PinnedValidationError) ErrorName() string {
	return "Request_Data_PinnedValidationError"
}

// Error satisfies the builtin error interface
func (e Request_Data_PinnedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data_Pinned.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_Data_PinnedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_Data_PinnedValidationError{}

// Validate checks the field values on Request_Data_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Request_Data_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Request_Data_DataMultiError, or nil if none found.
func (m *Request_Data_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProps()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_Data_DataValidationError{
					field:  "Props",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_Data_DataValidationError{
					field:  "Props",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProps()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_Data_DataValidationError{
				field:  "Props",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetQuotas()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_Data_DataValidationError{
					field:  "Quotas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_Data_DataValidationError{
					field:  "Quotas",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQuotas()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_Data_DataValidationError{
				field:  "Quotas",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.DConfig != nil {

		if all {
			switch v := interface{}(m.GetDConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Request_Data_DataValidationError{
						field:  "DConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Request_Data_DataValidationError{
						field:  "DConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Request_Data_DataValidationError{
					field:  "DConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.AConfig != nil {

		if all {
			switch v := interface{}(m.GetAConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Request_Data_DataValidationError{
						field:  "AConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Request_Data_DataValidationError{
						field:  "AConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Request_Data_DataValidationError{
					field:  "AConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Request_Data_DataMultiError(errors)
	}

	return nil
}

// Request_Data_DataMultiError is an error wrapping multiple validation errors
// returned by Request_Data_Data.ValidateAll() if the designated constraints
// aren't met.
type Request_Data_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_Data_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_Data_DataMultiError) AllErrors() []error { return m }

// Request_Data_DataValidationError is the validation error returned by
// Request_Data_Data.Validate if the designated constraints aren't met.
type Request_Data_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_Data_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_Data_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_Data_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_Data_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_Data_DataValidationError) ErrorName() string {
	return "Request_Data_DataValidationError"
}

// Error satisfies the builtin error interface
func (e Request_Data_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_Data_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_Data_DataValidationError{}

// Validate checks the field values on Request_Data_Data_Props with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Request_Data_Data_Props) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data_Data_Props with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Request_Data_Data_PropsMultiError, or nil if none found.
func (m *Request_Data_Data_Props) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data_Data_Props) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetActionConfiguration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_Data_Data_PropsValidationError{
					field:  "ActionConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_Data_Data_PropsValidationError{
					field:  "ActionConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionConfiguration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_Data_Data_PropsValidationError{
				field:  "ActionConfiguration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatasourceConfiguration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_Data_Data_PropsValidationError{
					field:  "DatasourceConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_Data_Data_PropsValidationError{
					field:  "DatasourceConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatasourceConfiguration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_Data_Data_PropsValidationError{
				field:  "DatasourceConfiguration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRedactedDatasourceConfiguration()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Request_Data_Data_PropsValidationError{
					field:  "RedactedDatasourceConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Request_Data_Data_PropsValidationError{
					field:  "RedactedDatasourceConfiguration",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRedactedDatasourceConfiguration()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Request_Data_Data_PropsValidationError{
				field:  "RedactedDatasourceConfiguration",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ExecutionId

	// no validation rules for StepName

	// no validation rules for Environment

	for idx, item := range m.GetBindingKeys() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Request_Data_Data_PropsValidationError{
						field:  fmt.Sprintf("BindingKeys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Request_Data_Data_PropsValidationError{
						field:  fmt.Sprintf("BindingKeys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Request_Data_Data_PropsValidationError{
					field:  fmt.Sprintf("BindingKeys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	{
		sorted_keys := make([]string, len(m.GetVariables()))
		i := 0
		for key := range m.GetVariables() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetVariables()[key]
			_ = val

			// no validation rules for Variables[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, Request_Data_Data_PropsValidationError{
							field:  fmt.Sprintf("Variables[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, Request_Data_Data_PropsValidationError{
							field:  fmt.Sprintf("Variables[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return Request_Data_Data_PropsValidationError{
						field:  fmt.Sprintf("Variables[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	// no validation rules for FileServerUrl

	for idx, item := range m.GetFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Request_Data_Data_PropsValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Request_Data_Data_PropsValidationError{
						field:  fmt.Sprintf("Files[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Request_Data_Data_PropsValidationError{
					field:  fmt.Sprintf("Files[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Render

	// no validation rules for Version

	if len(errors) > 0 {
		return Request_Data_Data_PropsMultiError(errors)
	}

	return nil
}

// Request_Data_Data_PropsMultiError is an error wrapping multiple validation
// errors returned by Request_Data_Data_Props.ValidateAll() if the designated
// constraints aren't met.
type Request_Data_Data_PropsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_Data_Data_PropsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_Data_Data_PropsMultiError) AllErrors() []error { return m }

// Request_Data_Data_PropsValidationError is the validation error returned by
// Request_Data_Data_Props.Validate if the designated constraints aren't met.
type Request_Data_Data_PropsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_Data_Data_PropsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_Data_Data_PropsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_Data_Data_PropsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_Data_Data_PropsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_Data_Data_PropsValidationError) ErrorName() string {
	return "Request_Data_Data_PropsValidationError"
}

// Error satisfies the builtin error interface
func (e Request_Data_Data_PropsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data_Data_Props.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_Data_Data_PropsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_Data_Data_PropsValidationError{}

// Validate checks the field values on Request_Data_Data_Quota with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Request_Data_Data_Quota) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data_Data_Quota with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Request_Data_Data_QuotaMultiError, or nil if none found.
func (m *Request_Data_Data_Quota) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data_Data_Quota) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Size

	// no validation rules for Duration

	if len(errors) > 0 {
		return Request_Data_Data_QuotaMultiError(errors)
	}

	return nil
}

// Request_Data_Data_QuotaMultiError is an error wrapping multiple validation
// errors returned by Request_Data_Data_Quota.ValidateAll() if the designated
// constraints aren't met.
type Request_Data_Data_QuotaMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_Data_Data_QuotaMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_Data_Data_QuotaMultiError) AllErrors() []error { return m }

// Request_Data_Data_QuotaValidationError is the validation error returned by
// Request_Data_Data_Quota.Validate if the designated constraints aren't met.
type Request_Data_Data_QuotaValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_Data_Data_QuotaValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_Data_Data_QuotaValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_Data_Data_QuotaValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_Data_Data_QuotaValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_Data_Data_QuotaValidationError) ErrorName() string {
	return "Request_Data_Data_QuotaValidationError"
}

// Error satisfies the builtin error interface
func (e Request_Data_Data_QuotaValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data_Data_Quota.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_Data_Data_QuotaValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_Data_Data_QuotaValidationError{}

// Validate checks the field values on Request_Data_Data_Props_Binding with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Request_Data_Data_Props_Binding) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data_Data_Props_Binding with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Request_Data_Data_Props_BindingMultiError, or nil if none found.
func (m *Request_Data_Data_Props_Binding) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data_Data_Props_Binding) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Type

	if len(errors) > 0 {
		return Request_Data_Data_Props_BindingMultiError(errors)
	}

	return nil
}

// Request_Data_Data_Props_BindingMultiError is an error wrapping multiple
// validation errors returned by Request_Data_Data_Props_Binding.ValidateAll()
// if the designated constraints aren't met.
type Request_Data_Data_Props_BindingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_Data_Data_Props_BindingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_Data_Data_Props_BindingMultiError) AllErrors() []error { return m }

// Request_Data_Data_Props_BindingValidationError is the validation error
// returned by Request_Data_Data_Props_Binding.Validate if the designated
// constraints aren't met.
type Request_Data_Data_Props_BindingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_Data_Data_Props_BindingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_Data_Data_Props_BindingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_Data_Data_Props_BindingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_Data_Data_Props_BindingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_Data_Data_Props_BindingValidationError) ErrorName() string {
	return "Request_Data_Data_Props_BindingValidationError"
}

// Error satisfies the builtin error interface
func (e Request_Data_Data_Props_BindingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data_Data_Props_Binding.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_Data_Data_Props_BindingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_Data_Data_Props_BindingValidationError{}

// Validate checks the field values on Request_Data_Data_Props_File with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Request_Data_Data_Props_File) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Request_Data_Data_Props_File with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Request_Data_Data_Props_FileMultiError, or nil if none found.
func (m *Request_Data_Data_Props_File) ValidateAll() error {
	return m.validate(true)
}

func (m *Request_Data_Data_Props_File) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Fieldname

	// no validation rules for Originalname

	// no validation rules for Encoding

	// no validation rules for Mimetype

	// no validation rules for Size

	// no validation rules for Destination

	// no validation rules for Filename

	// no validation rules for Path

	// no validation rules for Buffer

	if len(errors) > 0 {
		return Request_Data_Data_Props_FileMultiError(errors)
	}

	return nil
}

// Request_Data_Data_Props_FileMultiError is an error wrapping multiple
// validation errors returned by Request_Data_Data_Props_File.ValidateAll() if
// the designated constraints aren't met.
type Request_Data_Data_Props_FileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Request_Data_Data_Props_FileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Request_Data_Data_Props_FileMultiError) AllErrors() []error { return m }

// Request_Data_Data_Props_FileValidationError is the validation error returned
// by Request_Data_Data_Props_File.Validate if the designated constraints
// aren't met.
type Request_Data_Data_Props_FileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Request_Data_Data_Props_FileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Request_Data_Data_Props_FileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Request_Data_Data_Props_FileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Request_Data_Data_Props_FileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Request_Data_Data_Props_FileValidationError) ErrorName() string {
	return "Request_Data_Data_Props_FileValidationError"
}

// Error satisfies the builtin error interface
func (e Request_Data_Data_Props_FileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequest_Data_Data_Props_File.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Request_Data_Data_Props_FileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Request_Data_Data_Props_FileValidationError{}

// Validate checks the field values on Response_Data with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Response_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Response_Data with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Response_DataMultiError, or
// nil if none found.
func (m *Response_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *Response_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPinned()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Response_DataValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Response_DataValidationError{
					field:  "Pinned",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPinned()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Response_DataValidationError{
				field:  "Pinned",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetData()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Response_DataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Response_DataValidationError{
					field:  "Data",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetData()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Response_DataValidationError{
				field:  "Data",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Response_DataMultiError(errors)
	}

	return nil
}

// Response_DataMultiError is an error wrapping multiple validation errors
// returned by Response_Data.ValidateAll() if the designated constraints
// aren't met.
type Response_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Response_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Response_DataMultiError) AllErrors() []error { return m }

// Response_DataValidationError is the validation error returned by
// Response_Data.Validate if the designated constraints aren't met.
type Response_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Response_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Response_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Response_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Response_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Response_DataValidationError) ErrorName() string { return "Response_DataValidationError" }

// Error satisfies the builtin error interface
func (e Response_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponse_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Response_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Response_DataValidationError{}

// Validate checks the field values on Response_Data_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Response_Data_Data) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Response_Data_Data with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Response_Data_DataMultiError, or nil if none found.
func (m *Response_Data_Data) ValidateAll() error {
	return m.validate(true)
}

func (m *Response_Data_Data) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if all {
		switch v := interface{}(m.GetErr()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Response_Data_DataValidationError{
					field:  "Err",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Response_Data_DataValidationError{
					field:  "Err",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetErr()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Response_Data_DataValidationError{
				field:  "Err",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetBuckets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  fmt.Sprintf("Buckets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  fmt.Sprintf("Buckets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.DbSchema != nil {

		if all {
			switch v := interface{}(m.GetDbSchema()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "DbSchema",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "DbSchema",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDbSchema()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "DbSchema",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Couchbase != nil {

		if all {
			switch v := interface{}(m.GetCouchbase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Couchbase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Couchbase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCouchbase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Couchbase",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Kafka != nil {

		if all {
			switch v := interface{}(m.GetKafka()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Kafka",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKafka()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Kafka",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Kinesis != nil {

		if all {
			switch v := interface{}(m.GetKinesis()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Kinesis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Kinesis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetKinesis()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Kinesis",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Cosmosdb != nil {

		if all {
			switch v := interface{}(m.GetCosmosdb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Cosmosdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Cosmosdb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCosmosdb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Cosmosdb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Adls != nil {

		if all {
			switch v := interface{}(m.GetAdls()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Adls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Adls",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAdls()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Adls",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Dynamodb != nil {

		if all {
			switch v := interface{}(m.GetDynamodb()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Dynamodb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Dynamodb",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDynamodb()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Dynamodb",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.GSheetsNextPageToken != nil {
		// no validation rules for GSheetsNextPageToken
	}

	if m.Graphql != nil {

		if all {
			switch v := interface{}(m.GetGraphql()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Graphql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, Response_Data_DataValidationError{
						field:  "Graphql",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGraphql()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return Response_Data_DataValidationError{
					field:  "Graphql",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return Response_Data_DataMultiError(errors)
	}

	return nil
}

// Response_Data_DataMultiError is an error wrapping multiple validation errors
// returned by Response_Data_Data.ValidateAll() if the designated constraints
// aren't met.
type Response_Data_DataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Response_Data_DataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Response_Data_DataMultiError) AllErrors() []error { return m }

// Response_Data_DataValidationError is the validation error returned by
// Response_Data_Data.Validate if the designated constraints aren't met.
type Response_Data_DataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Response_Data_DataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Response_Data_DataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Response_Data_DataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Response_Data_DataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Response_Data_DataValidationError) ErrorName() string {
	return "Response_Data_DataValidationError"
}

// Error satisfies the builtin error interface
func (e Response_Data_DataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResponse_Data_Data.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Response_Data_DataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Response_Data_DataValidationError{}

// Validate checks the field values on Fetch_Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Fetch_Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Fetch_Metadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Fetch_MetadataMultiError,
// or nil if none found.
func (m *Fetch_Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Fetch_Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Requester

	// no validation rules for Profile

	// no validation rules for OrganizationPlan

	if len(errors) > 0 {
		return Fetch_MetadataMultiError(errors)
	}

	return nil
}

// Fetch_MetadataMultiError is an error wrapping multiple validation errors
// returned by Fetch_Metadata.ValidateAll() if the designated constraints
// aren't met.
type Fetch_MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Fetch_MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Fetch_MetadataMultiError) AllErrors() []error { return m }

// Fetch_MetadataValidationError is the validation error returned by
// Fetch_Metadata.Validate if the designated constraints aren't met.
type Fetch_MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Fetch_MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Fetch_MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Fetch_MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Fetch_MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Fetch_MetadataValidationError) ErrorName() string { return "Fetch_MetadataValidationError" }

// Error satisfies the builtin error interface
func (e Fetch_MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFetch_Metadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Fetch_MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Fetch_MetadataValidationError{}
